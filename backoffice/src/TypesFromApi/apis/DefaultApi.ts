/* tslint:disable */
/* eslint-disable */
/**
 * pass Culture backoffice API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import {
  AuthTokenResponseModel,
  AuthTokenResponseModelFromJSON,
  AuthTokenResponseModelToJSON,
  BeneficiaryReviewRequestModel,
  BeneficiaryReviewRequestModelFromJSON,
  BeneficiaryReviewRequestModelToJSON,
  BeneficiaryReviewResponseModel,
  BeneficiaryReviewResponseModelFromJSON,
  BeneficiaryReviewResponseModelToJSON,
  CommentRequest,
  CommentRequestFromJSON,
  CommentRequestToJSON,
  GetBeneficiaryCreditResponseModel,
  GetBeneficiaryCreditResponseModelFromJSON,
  GetBeneficiaryCreditResponseModelToJSON,
  GetUserSubscriptionHistoryResponseModel,
  GetUserSubscriptionHistoryResponseModelFromJSON,
  GetUserSubscriptionHistoryResponseModelToJSON,
  HistoryResponseModel,
  HistoryResponseModelFromJSON,
  HistoryResponseModelToJSON,
  IsTopActorRequest,
  IsTopActorRequestFromJSON,
  IsTopActorRequestToJSON,
  ListOffererToBeValidatedResponseModel,
  ListOffererToBeValidatedResponseModelFromJSON,
  ListOffererToBeValidatedResponseModelToJSON,
  ListPermissionResponseModel,
  ListPermissionResponseModelFromJSON,
  ListPermissionResponseModelToJSON,
  ListPublicAccountsResponseModel,
  ListPublicAccountsResponseModelFromJSON,
  ListPublicAccountsResponseModelToJSON,
  ListRoleResponseModel,
  ListRoleResponseModelFromJSON,
  ListRoleResponseModelToJSON,
  OffererAttachedUsersResponseModel,
  OffererAttachedUsersResponseModelFromJSON,
  OffererAttachedUsersResponseModelToJSON,
  OffererBasicInfoResponseModel,
  OffererBasicInfoResponseModelFromJSON,
  OffererBasicInfoResponseModelToJSON,
  OffererOfferStatsResponseModel,
  OffererOfferStatsResponseModelFromJSON,
  OffererOfferStatsResponseModelToJSON,
  OffererTagsResponseModel,
  OffererTagsResponseModelFromJSON,
  OffererTagsResponseModelToJSON,
  OffererTotalRevenueResponseModel,
  OffererTotalRevenueResponseModelFromJSON,
  OffererTotalRevenueResponseModelToJSON,
  OptionalCommentRequest,
  OptionalCommentRequestFromJSON,
  OptionalCommentRequestToJSON,
  PublicAccount,
  PublicAccountFromJSON,
  PublicAccountToJSON,
  PublicAccountUpdateRequest,
  PublicAccountUpdateRequestFromJSON,
  PublicAccountUpdateRequestToJSON,
  PublicHistoryResponseModel,
  PublicHistoryResponseModelFromJSON,
  PublicHistoryResponseModelToJSON,
  Response,
  ResponseFromJSON,
  ResponseToJSON,
  Role,
  RoleFromJSON,
  RoleToJSON,
  RoleRequestModel,
  RoleRequestModelFromJSON,
  RoleRequestModelToJSON,
  SearchProResponseModel,
  SearchProResponseModelFromJSON,
  SearchProResponseModelToJSON,
  ToBeValidatedOffererFilter,
  ToBeValidatedOffererFilterFromJSON,
  ToBeValidatedOffererFilterToJSON,
  ValidationErrorElement,
  ValidationErrorElementFromJSON,
  ValidationErrorElementToJSON,
} from '../models'

export interface AddTagToOffererRequest {
  offererId: number
  tagName: string
}

export interface CommentOffererRequest {
  offererId: number
  commentRequest?: CommentRequest
}

export interface CommentOffererAttachmentRequest {
  userOffererId: number
  commentRequest?: CommentRequest
}

export interface CreateRoleRequest {
  roleRequestModel?: RoleRequestModel
}

export interface DeleteRoleRequest {
  id: number
}

export interface GetAuthTokenRequest {
  token: string
}

export interface GetBeneficiaryCreditRequest {
  userId: number
}

export interface GetOffererBasicInfoRequest {
  offererId: number
}

export interface GetOffererHistoryRequest {
  offererId: number
}

export interface GetOffererOffersStatsRequest {
  offererId: number
}

export interface GetOffererTotalRevenueRequest {
  offererId: number
}

export interface GetOffererUsersRequest {
  offererId: number
}

export interface GetPublicAccountRequest {
  userId: number
}

export interface GetPublicHistoryRequest {
  userId: number
}

export interface GetUserSubscriptionHistoryRequest {
  userId: number
}

export interface GetVenueBasicInfoRequest {
  venueId: number
}

export interface GetVenueOffersStatsRequest {
  venueId: number
}

export interface GetVenueTotalRevenueRequest {
  venueId: number
}

export interface ListOfferersToBeValidatedRequest {
  filter?: Array<ToBeValidatedOffererFilter>
  page?: number | null
  perPage?: number | null
  sort?: string | null
}

export interface RejectOffererRequest {
  offererId: number
  optionalCommentRequest?: OptionalCommentRequest
}

export interface RejectOffererAttachmentRequest {
  userOffererId: number
  optionalCommentRequest?: OptionalCommentRequest
}

export interface RemoveTagFromOffererRequest {
  offererId: number
  tagName: string
}

export interface ResendValidationEmailRequest {
  userId: number
}

export interface ReviewPublicAccountRequest {
  userId: number
  beneficiaryReviewRequestModel?: BeneficiaryReviewRequestModel
}

export interface SearchProRequest {
  q: string
  type: string
  page?: number | null
  perPage?: number | null
  sort?: string | null
}

export interface SearchPublicAccountRequest {
  q: string
  page?: number | null
  perPage?: number | null
  sort?: string | null
}

export interface SendPhoneValidationCodeRequest {
  userId: number
}

export interface SetOffererAttachmentPendingRequest {
  userOffererId: number
  optionalCommentRequest?: OptionalCommentRequest
}

export interface SetOffererPendingRequest {
  offererId: number
  optionalCommentRequest?: OptionalCommentRequest
}

export interface SkipPhoneValidationRequest {
  userId: number
}

export interface ToggleTopActorRequest {
  offererId: number
  isTopActorRequest?: IsTopActorRequest
}

export interface UpdatePublicAccountRequest {
  userId: number
  publicAccountUpdateRequest?: PublicAccountUpdateRequest
}

export interface UpdateRoleRequest {
  id: number
  roleRequestModel?: RoleRequestModel
}

export interface ValidateOffererRequest {
  offererId: number
}

export interface ValidateOffererAttachmentRequest {
  userOffererId: number
}

/**
 * no description
 */
export class DefaultApi extends runtime.BaseAPI {
  /**
   * add_tag_to_offerer <POST>
   */
  async addTagToOffererRaw(
    requestParameters: AddTagToOffererRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling addTagToOfferer.'
      )
    }

    if (
      requestParameters.tagName === null ||
      requestParameters.tagName === undefined
    ) {
      throw new runtime.RequiredError(
        'tagName',
        'Required parameter requestParameters.tagName was null or undefined when calling addTagToOfferer.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/tags/{tag_name}`
        .replace(
          `{${'offerer_id'}}`,
          encodeURIComponent(String(requestParameters.offererId))
        )
        .replace(
          `{${'tag_name'}}`,
          encodeURIComponent(String(requestParameters.tagName))
        ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * add_tag_to_offerer <POST>
   */
  async addTagToOfferer(
    requestParameters: AddTagToOffererRequest
  ): Promise<void> {
    await this.addTagToOffererRaw(requestParameters)
  }

  /**
   * comment_offerer <POST>
   */
  async commentOffererRaw(
    requestParameters: CommentOffererRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling commentOfferer.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/comment`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(requestParameters.offererId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: CommentRequestToJSON(requestParameters.commentRequest),
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * comment_offerer <POST>
   */
  async commentOfferer(
    requestParameters: CommentOffererRequest
  ): Promise<void> {
    await this.commentOffererRaw(requestParameters)
  }

  /**
   * comment_offerer_attachment <POST>
   */
  async commentOffererAttachmentRaw(
    requestParameters: CommentOffererAttachmentRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.userOffererId === null ||
      requestParameters.userOffererId === undefined
    ) {
      throw new runtime.RequiredError(
        'userOffererId',
        'Required parameter requestParameters.userOffererId was null or undefined when calling commentOffererAttachment.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/users_offerers/{user_offerer_id}/comment`.replace(
        `{${'user_offerer_id'}}`,
        encodeURIComponent(String(requestParameters.userOffererId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: CommentRequestToJSON(requestParameters.commentRequest),
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * comment_offerer_attachment <POST>
   */
  async commentOffererAttachment(
    requestParameters: CommentOffererAttachmentRequest
  ): Promise<void> {
    await this.commentOffererAttachmentRaw(requestParameters)
  }

  /**
   * create_role <POST>
   */
  async createRoleRaw(
    requestParameters: CreateRoleRequest
  ): Promise<runtime.ApiResponse<Role>> {
    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/roles`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: RoleRequestModelToJSON(requestParameters.roleRequestModel),
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      RoleFromJSON(jsonValue)
    )
  }

  /**
   * create_role <POST>
   */
  async createRole(requestParameters: CreateRoleRequest): Promise<Role> {
    const response = await this.createRoleRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete_role <DELETE>
   */
  async deleteRoleRaw(
    requestParameters: DeleteRoleRequest
  ): Promise<runtime.ApiResponse<Role>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling deleteRole.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/roles/{id_}`.replace(
        `{${'id_'}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      RoleFromJSON(jsonValue)
    )
  }

  /**
   * delete_role <DELETE>
   */
  async deleteRole(requestParameters: DeleteRoleRequest): Promise<Role> {
    const response = await this.deleteRoleRaw(requestParameters)
    return await response.value()
  }

  /**
   * A Google tokenId can be obtained using [this Google login demo](https://anthonyjgrove.github.io/react-google-login). Once logged, the Google tokenId is available in the console in the `clicked[0].tokenId` field.
   * Gets a JWT token containing the email and the permission of user from a Google tokenId.
   */
  async getAuthTokenRaw(
    requestParameters: GetAuthTokenRequest
  ): Promise<runtime.ApiResponse<AuthTokenResponseModel>> {
    if (
      requestParameters.token === null ||
      requestParameters.token === undefined
    ) {
      throw new runtime.RequiredError(
        'token',
        'Required parameter requestParameters.token was null or undefined when calling getAuthToken.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    if (requestParameters.token !== undefined) {
      queryParameters['token'] = requestParameters.token
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/backoffice/auth/token`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      AuthTokenResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * A Google tokenId can be obtained using [this Google login demo](https://anthonyjgrove.github.io/react-google-login). Once logged, the Google tokenId is available in the console in the `clicked[0].tokenId` field.
   * Gets a JWT token containing the email and the permission of user from a Google tokenId.
   */
  async getAuthToken(
    requestParameters: GetAuthTokenRequest
  ): Promise<AuthTokenResponseModel> {
    const response = await this.getAuthTokenRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_beneficiary_credit <GET>
   */
  async getBeneficiaryCreditRaw(
    requestParameters: GetBeneficiaryCreditRequest
  ): Promise<runtime.ApiResponse<GetBeneficiaryCreditResponseModel>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling getBeneficiaryCredit.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/credit`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      GetBeneficiaryCreditResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * get_beneficiary_credit <GET>
   */
  async getBeneficiaryCredit(
    requestParameters: GetBeneficiaryCreditRequest
  ): Promise<GetBeneficiaryCreditResponseModel> {
    const response = await this.getBeneficiaryCreditRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_offerer_basic_info <GET>
   */
  async getOffererBasicInfoRaw(
    requestParameters: GetOffererBasicInfoRequest
  ): Promise<runtime.ApiResponse<OffererBasicInfoResponseModel>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling getOffererBasicInfo.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(requestParameters.offererId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      OffererBasicInfoResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * get_offerer_basic_info <GET>
   */
  async getOffererBasicInfo(
    requestParameters: GetOffererBasicInfoRequest
  ): Promise<OffererBasicInfoResponseModel> {
    const response = await this.getOffererBasicInfoRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_offerer_history <GET>
   */
  async getOffererHistoryRaw(
    requestParameters: GetOffererHistoryRequest
  ): Promise<runtime.ApiResponse<HistoryResponseModel>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling getOffererHistory.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/history`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(requestParameters.offererId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      HistoryResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * get_offerer_history <GET>
   */
  async getOffererHistory(
    requestParameters: GetOffererHistoryRequest
  ): Promise<HistoryResponseModel> {
    const response = await this.getOffererHistoryRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_offerer_offers_stats <GET>
   */
  async getOffererOffersStatsRaw(
    requestParameters: GetOffererOffersStatsRequest
  ): Promise<runtime.ApiResponse<OffererOfferStatsResponseModel>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling getOffererOffersStats.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/offers_stats`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(requestParameters.offererId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      OffererOfferStatsResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * get_offerer_offers_stats <GET>
   */
  async getOffererOffersStats(
    requestParameters: GetOffererOffersStatsRequest
  ): Promise<OffererOfferStatsResponseModel> {
    const response = await this.getOffererOffersStatsRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_offerer_total_revenue <GET>
   */
  async getOffererTotalRevenueRaw(
    requestParameters: GetOffererTotalRevenueRequest
  ): Promise<runtime.ApiResponse<OffererTotalRevenueResponseModel>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling getOffererTotalRevenue.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/total_revenue`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(requestParameters.offererId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      OffererTotalRevenueResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * get_offerer_total_revenue <GET>
   */
  async getOffererTotalRevenue(
    requestParameters: GetOffererTotalRevenueRequest
  ): Promise<OffererTotalRevenueResponseModel> {
    const response = await this.getOffererTotalRevenueRaw(requestParameters)
    return await response.value()
  }

  /**
   * Get the list of all (pro) users attached to the offerer
   */
  async getOffererUsersRaw(
    requestParameters: GetOffererUsersRequest
  ): Promise<runtime.ApiResponse<OffererAttachedUsersResponseModel>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling getOffererUsers.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/users`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(requestParameters.offererId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      OffererAttachedUsersResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * Get the list of all (pro) users attached to the offerer
   */
  async getOffererUsers(
    requestParameters: GetOffererUsersRequest
  ): Promise<OffererAttachedUsersResponseModel> {
    const response = await this.getOffererUsersRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_offerers_tags_list <GET>
   */
  async getOfferersTagsListRaw(): Promise<
    runtime.ApiResponse<OffererTagsResponseModel>
  > {
    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/tags`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      OffererTagsResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * get_offerers_tags_list <GET>
   */
  async getOfferersTagsList(): Promise<OffererTagsResponseModel> {
    const response = await this.getOfferersTagsListRaw()
    return await response.value()
  }

  /**
   * get_public_account <GET>
   */
  async getPublicAccountRaw(
    requestParameters: GetPublicAccountRequest
  ): Promise<runtime.ApiResponse<PublicAccount>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling getPublicAccount.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      PublicAccountFromJSON(jsonValue)
    )
  }

  /**
   * get_public_account <GET>
   */
  async getPublicAccount(
    requestParameters: GetPublicAccountRequest
  ): Promise<PublicAccount> {
    const response = await this.getPublicAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_public_history <GET>
   */
  async getPublicHistoryRaw(
    requestParameters: GetPublicHistoryRequest
  ): Promise<runtime.ApiResponse<PublicHistoryResponseModel>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling getPublicHistory.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/logs`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      PublicHistoryResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * get_public_history <GET>
   */
  async getPublicHistory(
    requestParameters: GetPublicHistoryRequest
  ): Promise<PublicHistoryResponseModel> {
    const response = await this.getPublicHistoryRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_user_subscription_history <GET>
   */
  async getUserSubscriptionHistoryRaw(
    requestParameters: GetUserSubscriptionHistoryRequest
  ): Promise<runtime.ApiResponse<GetUserSubscriptionHistoryResponseModel>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling getUserSubscriptionHistory.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/history`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      GetUserSubscriptionHistoryResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * get_user_subscription_history <GET>
   */
  async getUserSubscriptionHistory(
    requestParameters: GetUserSubscriptionHistoryRequest
  ): Promise<GetUserSubscriptionHistoryResponseModel> {
    const response = await this.getUserSubscriptionHistoryRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_venue_basic_info <GET>
   */
  async getVenueBasicInfoRaw(
    requestParameters: GetVenueBasicInfoRequest
  ): Promise<runtime.ApiResponse<Response>> {
    if (
      requestParameters.venueId === null ||
      requestParameters.venueId === undefined
    ) {
      throw new runtime.RequiredError(
        'venueId',
        'Required parameter requestParameters.venueId was null or undefined when calling getVenueBasicInfo.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/venues/{venue_id}`.replace(
        `{${'venue_id'}}`,
        encodeURIComponent(String(requestParameters.venueId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      ResponseFromJSON(jsonValue)
    )
  }

  /**
   * get_venue_basic_info <GET>
   */
  async getVenueBasicInfo(
    requestParameters: GetVenueBasicInfoRequest
  ): Promise<Response> {
    const response = await this.getVenueBasicInfoRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_venue_offers_stats <GET>
   */
  async getVenueOffersStatsRaw(
    requestParameters: GetVenueOffersStatsRequest
  ): Promise<runtime.ApiResponse<Response>> {
    if (
      requestParameters.venueId === null ||
      requestParameters.venueId === undefined
    ) {
      throw new runtime.RequiredError(
        'venueId',
        'Required parameter requestParameters.venueId was null or undefined when calling getVenueOffersStats.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/venues/{venue_id}/offers_stats`.replace(
        `{${'venue_id'}}`,
        encodeURIComponent(String(requestParameters.venueId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      ResponseFromJSON(jsonValue)
    )
  }

  /**
   * get_venue_offers_stats <GET>
   */
  async getVenueOffersStats(
    requestParameters: GetVenueOffersStatsRequest
  ): Promise<Response> {
    const response = await this.getVenueOffersStatsRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_venue_total_revenue <GET>
   */
  async getVenueTotalRevenueRaw(
    requestParameters: GetVenueTotalRevenueRequest
  ): Promise<runtime.ApiResponse<Response>> {
    if (
      requestParameters.venueId === null ||
      requestParameters.venueId === undefined
    ) {
      throw new runtime.RequiredError(
        'venueId',
        'Required parameter requestParameters.venueId was null or undefined when calling getVenueTotalRevenue.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/venues/{venue_id}/total_revenue`.replace(
        `{${'venue_id'}}`,
        encodeURIComponent(String(requestParameters.venueId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      ResponseFromJSON(jsonValue)
    )
  }

  /**
   * get_venue_total_revenue <GET>
   */
  async getVenueTotalRevenue(
    requestParameters: GetVenueTotalRevenueRequest
  ): Promise<Response> {
    const response = await this.getVenueTotalRevenueRaw(requestParameters)
    return await response.value()
  }

  /**
   * list_offerers_to_be_validated <GET>
   */
  async listOfferersToBeValidatedRaw(
    requestParameters: ListOfferersToBeValidatedRequest
  ): Promise<runtime.ApiResponse<ListOffererToBeValidatedResponseModel>> {
    const queryParameters: runtime.HTTPQuery = {}

    if (requestParameters.filter) {
      //queryParameters['filter'] = requestParameters.filter
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page
    }

    if (requestParameters.perPage !== undefined) {
      queryParameters['perPage'] = requestParameters.perPage
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/to_be_validated`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      ListOffererToBeValidatedResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * list_offerers_to_be_validated <GET>
   */
  async listOfferersToBeValidated(
    requestParameters: ListOfferersToBeValidatedRequest
  ): Promise<ListOffererToBeValidatedResponseModel> {
    const response = await this.listOfferersToBeValidatedRaw(requestParameters)
    return await response.value()
  }

  /**
   * list_permissions <GET>
   */
  async listPermissionsRaw(): Promise<
    runtime.ApiResponse<ListPermissionResponseModel>
  > {
    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/permissions`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      ListPermissionResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * list_permissions <GET>
   */
  async listPermissions(): Promise<ListPermissionResponseModel> {
    const response = await this.listPermissionsRaw()
    return await response.value()
  }

  /**
   * list_roles <GET>
   */
  async listRolesRaw(): Promise<runtime.ApiResponse<ListRoleResponseModel>> {
    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/roles`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      ListRoleResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * list_roles <GET>
   */
  async listRoles(): Promise<ListRoleResponseModel> {
    const response = await this.listRolesRaw()
    return await response.value()
  }

  /**
   * reject_offerer <POST>
   */
  async rejectOffererRaw(
    requestParameters: RejectOffererRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling rejectOfferer.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/reject`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(requestParameters.offererId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: OptionalCommentRequestToJSON(
        requestParameters.optionalCommentRequest
      ),
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * reject_offerer <POST>
   */
  async rejectOfferer(requestParameters: RejectOffererRequest): Promise<void> {
    await this.rejectOffererRaw(requestParameters)
  }

  /**
   * reject_offerer_attachment <POST>
   */
  async rejectOffererAttachmentRaw(
    requestParameters: RejectOffererAttachmentRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.userOffererId === null ||
      requestParameters.userOffererId === undefined
    ) {
      throw new runtime.RequiredError(
        'userOffererId',
        'Required parameter requestParameters.userOffererId was null or undefined when calling rejectOffererAttachment.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/users_offerers/{user_offerer_id}/reject`.replace(
        `{${'user_offerer_id'}}`,
        encodeURIComponent(String(requestParameters.userOffererId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: OptionalCommentRequestToJSON(
        requestParameters.optionalCommentRequest
      ),
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * reject_offerer_attachment <POST>
   */
  async rejectOffererAttachment(
    requestParameters: RejectOffererAttachmentRequest
  ): Promise<void> {
    await this.rejectOffererAttachmentRaw(requestParameters)
  }

  /**
   * remove_tag_from_offerer <DELETE>
   */
  async removeTagFromOffererRaw(
    requestParameters: RemoveTagFromOffererRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling removeTagFromOfferer.'
      )
    }

    if (
      requestParameters.tagName === null ||
      requestParameters.tagName === undefined
    ) {
      throw new runtime.RequiredError(
        'tagName',
        'Required parameter requestParameters.tagName was null or undefined when calling removeTagFromOfferer.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/tags/{tag_name}`
        .replace(
          `{${'offerer_id'}}`,
          encodeURIComponent(String(requestParameters.offererId))
        )
        .replace(
          `{${'tag_name'}}`,
          encodeURIComponent(String(requestParameters.tagName))
        ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * remove_tag_from_offerer <DELETE>
   */
  async removeTagFromOfferer(
    requestParameters: RemoveTagFromOffererRequest
  ): Promise<void> {
    await this.removeTagFromOffererRaw(requestParameters)
  }

  /**
   * resend_validation_email <POST>
   */
  async resendValidationEmailRaw(
    requestParameters: ResendValidationEmailRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling resendValidationEmail.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/resend-validation-email`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * resend_validation_email <POST>
   */
  async resendValidationEmail(
    requestParameters: ResendValidationEmailRequest
  ): Promise<void> {
    await this.resendValidationEmailRaw(requestParameters)
  }

  /**
   * review_public_account <POST>
   */
  async reviewPublicAccountRaw(
    requestParameters: ReviewPublicAccountRequest
  ): Promise<runtime.ApiResponse<BeneficiaryReviewResponseModel>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling reviewPublicAccount.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/review`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: BeneficiaryReviewRequestModelToJSON(
        requestParameters.beneficiaryReviewRequestModel
      ),
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      BeneficiaryReviewResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * review_public_account <POST>
   */
  async reviewPublicAccount(
    requestParameters: ReviewPublicAccountRequest
  ): Promise<BeneficiaryReviewResponseModel> {
    const response = await this.reviewPublicAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * search_pro <GET>
   */
  async searchProRaw(
    requestParameters: SearchProRequest
  ): Promise<runtime.ApiResponse<SearchProResponseModel>> {
    if (requestParameters.q === null || requestParameters.q === undefined) {
      throw new runtime.RequiredError(
        'q',
        'Required parameter requestParameters.q was null or undefined when calling searchPro.'
      )
    }

    if (
      requestParameters.type === null ||
      requestParameters.type === undefined
    ) {
      throw new runtime.RequiredError(
        'type',
        'Required parameter requestParameters.type was null or undefined when calling searchPro.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page
    }

    if (requestParameters.perPage !== undefined) {
      queryParameters['perPage'] = requestParameters.perPage
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q
    }

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/pro/search`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      SearchProResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * search_pro <GET>
   */
  async searchPro(
    requestParameters: SearchProRequest
  ): Promise<SearchProResponseModel> {
    const response = await this.searchProRaw(requestParameters)
    return await response.value()
  }

  /**
   * search_public_account <GET>
   */
  async searchPublicAccountRaw(
    requestParameters: SearchPublicAccountRequest
  ): Promise<runtime.ApiResponse<ListPublicAccountsResponseModel>> {
    if (requestParameters.q === null || requestParameters.q === undefined) {
      throw new runtime.RequiredError(
        'q',
        'Required parameter requestParameters.q was null or undefined when calling searchPublicAccount.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page
    }

    if (requestParameters.perPage !== undefined) {
      queryParameters['perPage'] = requestParameters.perPage
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/search`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      ListPublicAccountsResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * search_public_account <GET>
   */
  async searchPublicAccount(
    requestParameters: SearchPublicAccountRequest
  ): Promise<ListPublicAccountsResponseModel> {
    const response = await this.searchPublicAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * send_phone_validation_code <POST>
   */
  async sendPhoneValidationCodeRaw(
    requestParameters: SendPhoneValidationCodeRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling sendPhoneValidationCode.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/send-phone-validation-code`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * send_phone_validation_code <POST>
   */
  async sendPhoneValidationCode(
    requestParameters: SendPhoneValidationCodeRequest
  ): Promise<void> {
    await this.sendPhoneValidationCodeRaw(requestParameters)
  }

  /**
   * set_offerer_attachment_pending <POST>
   */
  async setOffererAttachmentPendingRaw(
    requestParameters: SetOffererAttachmentPendingRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.userOffererId === null ||
      requestParameters.userOffererId === undefined
    ) {
      throw new runtime.RequiredError(
        'userOffererId',
        'Required parameter requestParameters.userOffererId was null or undefined when calling setOffererAttachmentPending.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/users_offerers/{user_offerer_id}/pending`.replace(
        `{${'user_offerer_id'}}`,
        encodeURIComponent(String(requestParameters.userOffererId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: OptionalCommentRequestToJSON(
        requestParameters.optionalCommentRequest
      ),
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * set_offerer_attachment_pending <POST>
   */
  async setOffererAttachmentPending(
    requestParameters: SetOffererAttachmentPendingRequest
  ): Promise<void> {
    await this.setOffererAttachmentPendingRaw(requestParameters)
  }

  /**
   * set_offerer_pending <POST>
   */
  async setOffererPendingRaw(
    requestParameters: SetOffererPendingRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling setOffererPending.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/pending`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(requestParameters.offererId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: OptionalCommentRequestToJSON(
        requestParameters.optionalCommentRequest
      ),
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * set_offerer_pending <POST>
   */
  async setOffererPending(
    requestParameters: SetOffererPendingRequest
  ): Promise<void> {
    await this.setOffererPendingRaw(requestParameters)
  }

  /**
   * skip_phone_validation <POST>
   */
  async skipPhoneValidationRaw(
    requestParameters: SkipPhoneValidationRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling skipPhoneValidation.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/skip-phone-validation`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * skip_phone_validation <POST>
   */
  async skipPhoneValidation(
    requestParameters: SkipPhoneValidationRequest
  ): Promise<void> {
    await this.skipPhoneValidationRaw(requestParameters)
  }

  /**
   * toggle_top_actor <PUT>
   */
  async toggleTopActorRaw(
    requestParameters: ToggleTopActorRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling toggleTopActor.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/is_top_actor`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(requestParameters.offererId))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: IsTopActorRequestToJSON(requestParameters.isTopActorRequest),
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * toggle_top_actor <PUT>
   */
  async toggleTopActor(
    requestParameters: ToggleTopActorRequest
  ): Promise<void> {
    await this.toggleTopActorRaw(requestParameters)
  }

  /**
   * update_public_account <PUT>
   */
  async updatePublicAccountRaw(
    requestParameters: UpdatePublicAccountRequest
  ): Promise<runtime.ApiResponse<PublicAccount>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling updatePublicAccount.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: PublicAccountUpdateRequestToJSON(
        requestParameters.publicAccountUpdateRequest
      ),
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      PublicAccountFromJSON(jsonValue)
    )
  }

  /**
   * update_public_account <PUT>
   */
  async updatePublicAccount(
    requestParameters: UpdatePublicAccountRequest
  ): Promise<PublicAccount> {
    const response = await this.updatePublicAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * update_role <PUT>
   */
  async updateRoleRaw(
    requestParameters: UpdateRoleRequest
  ): Promise<runtime.ApiResponse<Role>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling updateRole.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/roles/{id_}`.replace(
        `{${'id_'}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: RoleRequestModelToJSON(requestParameters.roleRequestModel),
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      RoleFromJSON(jsonValue)
    )
  }

  /**
   * update_role <PUT>
   */
  async updateRole(requestParameters: UpdateRoleRequest): Promise<Role> {
    const response = await this.updateRoleRaw(requestParameters)
    return await response.value()
  }

  /**
   * validate_offerer <POST>
   */
  async validateOffererRaw(
    requestParameters: ValidateOffererRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling validateOfferer.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/validate`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(requestParameters.offererId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * validate_offerer <POST>
   */
  async validateOfferer(
    requestParameters: ValidateOffererRequest
  ): Promise<void> {
    await this.validateOffererRaw(requestParameters)
  }

  /**
   * validate_offerer_attachment <POST>
   */
  async validateOffererAttachmentRaw(
    requestParameters: ValidateOffererAttachmentRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.userOffererId === null ||
      requestParameters.userOffererId === undefined
    ) {
      throw new runtime.RequiredError(
        'userOffererId',
        'Required parameter requestParameters.userOffererId was null or undefined when calling validateOffererAttachment.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/users_offerers/{user_offerer_id}/validate`.replace(
        `{${'user_offerer_id'}}`,
        encodeURIComponent(String(requestParameters.userOffererId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * validate_offerer_attachment <POST>
   */
  async validateOffererAttachment(
    requestParameters: ValidateOffererAttachmentRequest
  ): Promise<void> {
    await this.validateOffererAttachmentRaw(requestParameters)
  }
}
