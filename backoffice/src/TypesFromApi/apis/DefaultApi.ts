/* tslint:disable */
/* eslint-disable */
/**
 * pass Culture backoffice API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime'
import {
  AuthTokenResponseModel,
  AuthTokenResponseModelFromJSON,
  AuthTokenResponseModelToJSON,
  BeneficiaryReviewRequestModel,
  BeneficiaryReviewRequestModelFromJSON,
  BeneficiaryReviewRequestModelToJSON,
  BeneficiaryReviewResponseModel,
  BeneficiaryReviewResponseModelFromJSON,
  BeneficiaryReviewResponseModelToJSON,
  GetBeneficiaryCreditResponseModel,
  GetBeneficiaryCreditResponseModelFromJSON,
  GetBeneficiaryCreditResponseModelToJSON,
  GetUserSubscriptionHistoryResponseModel,
  GetUserSubscriptionHistoryResponseModelFromJSON,
  GetUserSubscriptionHistoryResponseModelToJSON,
  ListPermissionResponseModel,
  ListPermissionResponseModelFromJSON,
  ListPermissionResponseModelToJSON,
  ListPublicAccountsResponseModel,
  ListPublicAccountsResponseModelFromJSON,
  ListPublicAccountsResponseModelToJSON,
  ListRoleResponseModel,
  ListRoleResponseModelFromJSON,
  ListRoleResponseModelToJSON,
  OffererAttachedUsersResponseModel,
  OffererAttachedUsersResponseModelFromJSON,
  OffererAttachedUsersResponseModelToJSON,
  PublicAccount,
  PublicAccountFromJSON,
  PublicAccountToJSON,
  PublicAccountUpdateRequest,
  PublicAccountUpdateRequestFromJSON,
  PublicAccountUpdateRequestToJSON,
  PublicHistoryResponseModel,
  PublicHistoryResponseModelFromJSON,
  PublicHistoryResponseModelToJSON,
  Role,
  RoleFromJSON,
  RoleToJSON,
  RoleRequestModel,
  RoleRequestModelFromJSON,
  RoleRequestModelToJSON,
  SearchProResponseModel,
  SearchProResponseModelFromJSON,
  SearchProResponseModelToJSON,
  ValidationErrorElement,
  ValidationErrorElementFromJSON,
  ValidationErrorElementToJSON,
} from '../models'

export interface CreateRoleRequest {
  roleRequestModel?: RoleRequestModel
}

export interface DeleteRoleRequest {
  id: number
}

export interface GetAuthTokenRequest {
  token: string
}

export interface GetBeneficiaryCreditRequest {
  userId: number
}

export interface GetOffererUsersRequest {
  offererId: number
}

export interface GetPublicAccountRequest {
  userId: number
}

export interface GetPublicHistoryRequest {
  userId: number
}

export interface GetUserSubscriptionHistoryRequest {
  userId: number
}

export interface ResendValidationEmailRequest {
  userId: number
}

export interface ReviewPublicAccountRequest {
  userId: number
  beneficiaryReviewRequestModel?: BeneficiaryReviewRequestModel
}

export interface SearchProRequest {
  q: string
  type: string
  page?: number | null
  perPage?: number | null
  sort?: string | null
}

export interface SearchPublicAccountRequest {
  q: string
  page?: number | null
  perPage?: number | null
  sort?: string | null
}

export interface SendPhoneValidationCodeRequest {
  userId: number
}

export interface SkipPhoneValidationRequest {
  userId: number
}

export interface UpdatePublicAccountRequest {
  userId: number
  publicAccountUpdateRequest?: PublicAccountUpdateRequest
}

export interface UpdateRoleRequest {
  id: number
  roleRequestModel?: RoleRequestModel
}

/**
 * no description
 */
export class DefaultApi extends runtime.BaseAPI {
  /**
   * create_role <POST>
   */
  async createRoleRaw(
    requestParameters: CreateRoleRequest
  ): Promise<runtime.ApiResponse<Role>> {
    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/roles`,
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: RoleRequestModelToJSON(requestParameters.roleRequestModel),
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      RoleFromJSON(jsonValue)
    )
  }

  /**
   * create_role <POST>
   */
  async createRole(requestParameters: CreateRoleRequest): Promise<Role> {
    const response = await this.createRoleRaw(requestParameters)
    return await response.value()
  }

  /**
   * delete_role <DELETE>
   */
  async deleteRoleRaw(
    requestParameters: DeleteRoleRequest
  ): Promise<runtime.ApiResponse<Role>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling deleteRole.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/roles/{id_}`.replace(
        `{${'id_'}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: 'DELETE',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      RoleFromJSON(jsonValue)
    )
  }

  /**
   * delete_role <DELETE>
   */
  async deleteRole(requestParameters: DeleteRoleRequest): Promise<Role> {
    const response = await this.deleteRoleRaw(requestParameters)
    return await response.value()
  }

  /**
   * A Google tokenId can be obtained using [this Google login demo](https://anthonyjgrove.github.io/react-google-login). Once logged, the Google tokenId is available in the console in the `clicked[0].tokenId` field.
   * Gets a JWT token containing the email and the permission of user from a Google tokenId.
   */
  async getAuthTokenRaw(
    requestParameters: GetAuthTokenRequest
  ): Promise<runtime.ApiResponse<AuthTokenResponseModel>> {
    if (
      requestParameters.token === null ||
      requestParameters.token === undefined
    ) {
      throw new runtime.RequiredError(
        'token',
        'Required parameter requestParameters.token was null or undefined when calling getAuthToken.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    if (requestParameters.token !== undefined) {
      queryParameters['token'] = requestParameters.token
    }

    const headerParameters: runtime.HTTPHeaders = {}

    const response = await this.request({
      path: `/backoffice/auth/token`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      AuthTokenResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * A Google tokenId can be obtained using [this Google login demo](https://anthonyjgrove.github.io/react-google-login). Once logged, the Google tokenId is available in the console in the `clicked[0].tokenId` field.
   * Gets a JWT token containing the email and the permission of user from a Google tokenId.
   */
  async getAuthToken(
    requestParameters: GetAuthTokenRequest
  ): Promise<AuthTokenResponseModel> {
    const response = await this.getAuthTokenRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_beneficiary_credit <GET>
   */
  async getBeneficiaryCreditRaw(
    requestParameters: GetBeneficiaryCreditRequest
  ): Promise<runtime.ApiResponse<GetBeneficiaryCreditResponseModel>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling getBeneficiaryCredit.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/credit`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      GetBeneficiaryCreditResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * get_beneficiary_credit <GET>
   */
  async getBeneficiaryCredit(
    requestParameters: GetBeneficiaryCreditRequest
  ): Promise<GetBeneficiaryCreditResponseModel> {
    const response = await this.getBeneficiaryCreditRaw(requestParameters)
    return await response.value()
  }

  /**
   * Get the list of all (pro) users attached to the offerer
   */
  async getOffererUsersRaw(
    requestParameters: GetOffererUsersRequest
  ): Promise<runtime.ApiResponse<OffererAttachedUsersResponseModel>> {
    if (
      requestParameters.offererId === null ||
      requestParameters.offererId === undefined
    ) {
      throw new runtime.RequiredError(
        'offererId',
        'Required parameter requestParameters.offererId was null or undefined when calling getOffererUsers.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/offerers/{offerer_id}/users`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(requestParameters.offererId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      OffererAttachedUsersResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * Get the list of all (pro) users attached to the offerer
   */
  async getOffererUsers(
    requestParameters: GetOffererUsersRequest
  ): Promise<OffererAttachedUsersResponseModel> {
    const response = await this.getOffererUsersRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_public_account <GET>
   */
  async getPublicAccountRaw(
    requestParameters: GetPublicAccountRequest
  ): Promise<runtime.ApiResponse<PublicAccount>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling getPublicAccount.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      PublicAccountFromJSON(jsonValue)
    )
  }

  /**
   * get_public_account <GET>
   */
  async getPublicAccount(
    requestParameters: GetPublicAccountRequest
  ): Promise<PublicAccount> {
    const response = await this.getPublicAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_public_history <GET>
   */
  async getPublicHistoryRaw(
    requestParameters: GetPublicHistoryRequest
  ): Promise<runtime.ApiResponse<PublicHistoryResponseModel>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling getPublicHistory.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/logs`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      PublicHistoryResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * get_public_history <GET>
   */
  async getPublicHistory(
    requestParameters: GetPublicHistoryRequest
  ): Promise<PublicHistoryResponseModel> {
    const response = await this.getPublicHistoryRaw(requestParameters)
    return await response.value()
  }

  /**
   * get_user_subscription_history <GET>
   */
  async getUserSubscriptionHistoryRaw(
    requestParameters: GetUserSubscriptionHistoryRequest
  ): Promise<runtime.ApiResponse<GetUserSubscriptionHistoryResponseModel>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling getUserSubscriptionHistory.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/history`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      GetUserSubscriptionHistoryResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * get_user_subscription_history <GET>
   */
  async getUserSubscriptionHistory(
    requestParameters: GetUserSubscriptionHistoryRequest
  ): Promise<GetUserSubscriptionHistoryResponseModel> {
    const response = await this.getUserSubscriptionHistoryRaw(requestParameters)
    return await response.value()
  }

  /**
   * list_permissions <GET>
   */
  async listPermissionsRaw(): Promise<
    runtime.ApiResponse<ListPermissionResponseModel>
  > {
    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/permissions`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      ListPermissionResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * list_permissions <GET>
   */
  async listPermissions(): Promise<ListPermissionResponseModel> {
    const response = await this.listPermissionsRaw()
    return await response.value()
  }

  /**
   * list_roles <GET>
   */
  async listRolesRaw(): Promise<runtime.ApiResponse<ListRoleResponseModel>> {
    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/roles`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      ListRoleResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * list_roles <GET>
   */
  async listRoles(): Promise<ListRoleResponseModel> {
    const response = await this.listRolesRaw()
    return await response.value()
  }

  /**
   * resend_validation_email <POST>
   */
  async resendValidationEmailRaw(
    requestParameters: ResendValidationEmailRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling resendValidationEmail.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/resend-validation-email`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * resend_validation_email <POST>
   */
  async resendValidationEmail(
    requestParameters: ResendValidationEmailRequest
  ): Promise<void> {
    await this.resendValidationEmailRaw(requestParameters)
  }

  /**
   * review_public_account <POST>
   */
  async reviewPublicAccountRaw(
    requestParameters: ReviewPublicAccountRequest
  ): Promise<runtime.ApiResponse<BeneficiaryReviewResponseModel>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling reviewPublicAccount.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/review`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
      body: BeneficiaryReviewRequestModelToJSON(
        requestParameters.beneficiaryReviewRequestModel
      ),
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      BeneficiaryReviewResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * review_public_account <POST>
   */
  async reviewPublicAccount(
    requestParameters: ReviewPublicAccountRequest
  ): Promise<BeneficiaryReviewResponseModel> {
    const response = await this.reviewPublicAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * search_pro <GET>
   */
  async searchProRaw(
    requestParameters: SearchProRequest
  ): Promise<runtime.ApiResponse<SearchProResponseModel>> {
    if (requestParameters.q === null || requestParameters.q === undefined) {
      throw new runtime.RequiredError(
        'q',
        'Required parameter requestParameters.q was null or undefined when calling searchPro.'
      )
    }

    if (
      requestParameters.type === null ||
      requestParameters.type === undefined
    ) {
      throw new runtime.RequiredError(
        'type',
        'Required parameter requestParameters.type was null or undefined when calling searchPro.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page
    }

    if (requestParameters.perPage !== undefined) {
      queryParameters['perPage'] = requestParameters.perPage
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q
    }

    if (requestParameters.type !== undefined) {
      queryParameters['type'] = requestParameters.type
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/pro/search`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      SearchProResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * search_pro <GET>
   */
  async searchPro(
    requestParameters: SearchProRequest
  ): Promise<SearchProResponseModel> {
    const response = await this.searchProRaw(requestParameters)
    return await response.value()
  }

  /**
   * search_public_account <GET>
   */
  async searchPublicAccountRaw(
    requestParameters: SearchPublicAccountRequest
  ): Promise<runtime.ApiResponse<ListPublicAccountsResponseModel>> {
    if (requestParameters.q === null || requestParameters.q === undefined) {
      throw new runtime.RequiredError(
        'q',
        'Required parameter requestParameters.q was null or undefined when calling searchPublicAccount.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page
    }

    if (requestParameters.perPage !== undefined) {
      queryParameters['perPage'] = requestParameters.perPage
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort
    }

    if (requestParameters.q !== undefined) {
      queryParameters['q'] = requestParameters.q
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/search`,
      method: 'GET',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      ListPublicAccountsResponseModelFromJSON(jsonValue)
    )
  }

  /**
   * search_public_account <GET>
   */
  async searchPublicAccount(
    requestParameters: SearchPublicAccountRequest
  ): Promise<ListPublicAccountsResponseModel> {
    const response = await this.searchPublicAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * send_phone_validation_code <POST>
   */
  async sendPhoneValidationCodeRaw(
    requestParameters: SendPhoneValidationCodeRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling sendPhoneValidationCode.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/send-phone-validation-code`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * send_phone_validation_code <POST>
   */
  async sendPhoneValidationCode(
    requestParameters: SendPhoneValidationCodeRequest
  ): Promise<void> {
    await this.sendPhoneValidationCodeRaw(requestParameters)
  }

  /**
   * skip_phone_validation <POST>
   */
  async skipPhoneValidationRaw(
    requestParameters: SkipPhoneValidationRequest
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling skipPhoneValidation.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}/skip-phone-validation`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'POST',
      headers: headerParameters,
      query: queryParameters,
    })

    return new runtime.VoidApiResponse(response)
  }

  /**
   * skip_phone_validation <POST>
   */
  async skipPhoneValidation(
    requestParameters: SkipPhoneValidationRequest
  ): Promise<void> {
    await this.skipPhoneValidationRaw(requestParameters)
  }

  /**
   * update_public_account <PUT>
   */
  async updatePublicAccountRaw(
    requestParameters: UpdatePublicAccountRequest
  ): Promise<runtime.ApiResponse<PublicAccount>> {
    if (
      requestParameters.userId === null ||
      requestParameters.userId === undefined
    ) {
      throw new runtime.RequiredError(
        'userId',
        'Required parameter requestParameters.userId was null or undefined when calling updatePublicAccount.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/public_accounts/{user_id}`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(requestParameters.userId))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: PublicAccountUpdateRequestToJSON(
        requestParameters.publicAccountUpdateRequest
      ),
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      PublicAccountFromJSON(jsonValue)
    )
  }

  /**
   * update_public_account <PUT>
   */
  async updatePublicAccount(
    requestParameters: UpdatePublicAccountRequest
  ): Promise<PublicAccount> {
    const response = await this.updatePublicAccountRaw(requestParameters)
    return await response.value()
  }

  /**
   * update_role <PUT>
   */
  async updateRoleRaw(
    requestParameters: UpdateRoleRequest
  ): Promise<runtime.ApiResponse<Role>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling updateRole.'
      )
    }

    const queryParameters: runtime.HTTPQuery = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters['Content-Type'] = 'application/json'

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString =
        typeof token === 'function' ? token('backoffice_auth', []) : token

      if (tokenString) {
        headerParameters['Authorization'] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request({
      path: `/backoffice/roles/{id_}`.replace(
        `{${'id_'}}`,
        encodeURIComponent(String(requestParameters.id))
      ),
      method: 'PUT',
      headers: headerParameters,
      query: queryParameters,
      body: RoleRequestModelToJSON(requestParameters.roleRequestModel),
    })

    return new runtime.JSONApiResponse(response, jsonValue =>
      RoleFromJSON(jsonValue)
    )
  }

  /**
   * update_role <PUT>
   */
  async updateRole(requestParameters: UpdateRoleRequest): Promise<Role> {
    const response = await this.updateRoleRaw(requestParameters)
    return await response.value()
  }
}
