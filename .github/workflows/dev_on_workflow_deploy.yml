name: "3 [on_workflow] Deploy"
on:
  workflow_call:
    inputs:
      environment:
        type: string
        required: true
      app_version:
        type: string
        required: true
      teleport_version:
        type: string
        required: true
      teleport_proxy:
        type: string
        required: true
      teleport_kubernetes_cluster:
        type: string
        required: true
      deploy_api:
        type: boolean
        required: false
        default: false
      deploy_pro:
        type: boolean
        required: false
        default: false
    secrets:
      GCP_EHP_WORKLOAD_IDENTITY_PROVIDER:
        required: true
      GCP_EHP_SERVICE_ACCOUNT:
        required: true

jobs:
  deploy-api:
    name: "Deploy api"
    if: ${{ inputs.deploy_api }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4.1.4
      - name: "Authentification to Google"
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: ${{ secrets.GCP_EHP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_EHP_SERVICE_ACCOUNT }}
      - name: "Get Secret"
        id: 'secrets'
        uses: 'google-github-actions/get-secretmanager-secrets@v2'
        with:
          secrets: |-
            PASSCULTURE_SA_ACCESS_TOKEN:passculture-metier-ehp/passculture-main-sa-access-token
            ARTIFACT_REGISTRY_WORKLOAD_IDENTITY_PROVIDER:passculture-metier-ehp/infra-prod-gcp-workload-identity-provider
            ARTIFACT_REGISTRY_SERVICE_ACCOUNT:passculture-metier-ehp/passculture-main-artifact-registry-service-account
      - uses: actions/checkout@v4.1.4
        with:
          repository: pass-culture/pass-culture-deployment
          token: ${{ steps.secrets.outputs.PASSCULTURE_SA_ACCESS_TOKEN }}
          path: ./pass-culture-deployment
      - name: "OpenID Connect Authentication"
        id: "openid-auth-infra"
        uses: 'google-github-actions/auth@v2'
        with:
          create_credentials_file: false
          token_format: 'access_token'
          workload_identity_provider: ${{ steps.secrets.outputs.ARTIFACT_REGISTRY_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ steps.secrets.outputs.ARTIFACT_REGISTRY_SERVICE_ACCOUNT }}
      - name: "Install Teleport"
        uses: teleport-actions/setup@v1
        with:
          version: ${{ inputs.teleport_version }}
      - name: "Teleport Authentication"
        uses: teleport-actions/auth-k8s@v1
        id: "teleport-auth"
        with:
          proxy: ${{ inputs.teleport_proxy }}
          token: github-token
          certificate-ttl: 1h
          kubernetes-cluster: ${{ inputs.teleport_kubernetes_cluster }}
      - name: "Setup helmfile"
        uses: mamezou-tech/setup-helmfile@v1.3.0
        with:
          helmfile-version: "v0.147.0"
      - name: "Play pre-migrations"
        run: |
          set -e
          VERSION="${{ inputs.app_version }}"
          export ENVIRONMENT="${{ inputs.environment }}"
          IMAGE=$(kubectl get -n ${{ inputs.environment }} po -l role=api -o json |jq -r '.items[0].spec.containers[0].image'|awk -F':' '{print $1}')
          export IMAGE="${IMAGE}:${VERSION}"
          export DATE=$(date +"%Y-%m-%d--%H-%M-%S")
          envsubst < .github/workflows/templates/pre-upgrade-job.yaml | kubectl -n ${{ inputs.environment }} apply -f -
          while true;
          do
          kubectl logs -n ${{ inputs.environment }} -f jobs/pre-upgrade-${DATE} && break
          done
          kubectl wait --for=condition=complete --timeout=10900s -n ${{ inputs.environment }} jobs/pre-upgrade-${DATE}
      - name: "Generate pcapi secrets list"
        id: generate-pcapi-secrets-list
        run: |
          #Retrieve pcapi secrets list from source code
          PCAPI_SECRETS=$(cat api/src/pcapi/settings.py | grep "secrets_utils.getlist(" | awk -F'=' '{print $1}')
          PCAPI_SECRETS+=$(cat api/src/pcapi/settings.py | grep "secrets_utils.get(" | grep -oP '(?<=secrets_utils.get\(\").*?(?=\")')
          #Sort list
          PCAPI_SECRETS=$(echo $PCAPI_SECRETS | xargs -n1 | sort | xargs)
          #Transform list into helm readable parameter list (pattern: --set value={item1,item2,item3})
          PCAPI_SECRETS=secrets={$(echo $PCAPI_SECRETS | sed -r 's/ /,/g')}
          echo "PCAPI_SECRETS=\"$PCAPI_SECRETS\"" >> "$GITHUB_OUTPUT"
      - name: "Render manifests"
        run: |
          PASSCULTURE_USERNAME="oauth2accesstoken" \
          PASSCULTURE_PASSWORD=${{ steps.openid-auth-infra.outputs.access_token }} \
          helmfile -e ${{ inputs.environment }} template --set ${{ steps.generate-pcapi-secrets-list.outputs.PCAPI_SECRETS }} --set image.tag=${{ inputs.app_version }} --output-dir ./rendered-manifests/ --output-dir-template "{{ .OutputDir }}/{{ .State.BaseName }}-{{ .Release.Name  }}"
      - name: "Push manifests to rendered-manifests repository"
        id: push-manifests
        uses: cpina/github-action-push-to-another-repository@main
        env:
          API_TOKEN_GITHUB: ${{ steps.secrets.outputs.PASSCULTURE_SA_ACCESS_TOKEN }}
        with:
          source-directory: ./rendered-manifests/helmfile-${{ inputs.environment }}/
          destination-github-username: 'pass-culture'
          destination-repository-name: 'rendered-manifests'
          commit-message: "pcapi(${{ inputs.environment }}) : pushed rendered manifests for app_version=${{ inputs.app_version }}"
          target-branch: ${{ inputs.environment }}
          create-target-branch-if-needed: true
      - name: "Install argocd cli"
        id: install_argocd_cli
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64
      - name: "Check argocd application status"
        id: check_status
        run: |
          kubectl config set-context --current --namespace=argocd
          argocd app sync pcapi-${{ inputs.environment }} --core --async
          argocd app wait pcapi-${{ inputs.environment }} --core --timeout 600
      - name: "Play post-migrations"
        run: |
          set -e
          VERSION="${{ inputs.app_version }}"
          export ENVIRONMENT="${{ inputs.environment }}"
          IMAGE=$(kubectl get -n ${{ inputs.environment }} po -l role=api -o json |jq -r '.items[0].spec.containers[0].image'|awk -F':' '{print $1}')
          export IMAGE="${IMAGE}:${VERSION}"
          export DATE=$(date +"%Y-%m-%d--%H-%M-%S")
          envsubst < .github/workflows/templates/post-upgrade-job.yaml | kubectl -n ${{ inputs.environment }} apply -f -
          while true;
          do
          kubectl logs -n ${{ inputs.environment }} -f jobs/post-upgrade-${DATE} && break
          done
          kubectl wait --for=condition=complete --timeout=10900s -n ${{ inputs.environment }} jobs/post-upgrade-${DATE}

  deploy-pro-on-testing-on-firebase:
    name: "Deploy pro on testing live channel"
    needs: deploy-api
    if: |
      always() &&
      (needs.deploy-api.result == 'success' || needs.deploy-api.result == 'skipped') &&
      inputs.environment == 'testing' &&
      inputs.deploy_pro == true
    uses: ./.github/workflows/dev_on_workflow_deploy_pro_pr_version_generic.yml
    secrets:
      GCP_EHP_SERVICE_ACCOUNT: ${{ secrets.GCP_EHP_SERVICE_ACCOUNT }}
      GCP_EHP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_EHP_WORKLOAD_IDENTITY_PROVIDER }}
    with:
      ENV: testing
      CHANNEL: "live"
      REF: ${{ github.ref }}
      CACHE_BUCKET_NAME: "passculture-infra-prod-github-runner-cache"

  deploy-pro-on-firebase:
    name: "Deploy pro"
    needs: deploy-api
    if: |
      always() &&
      (needs.deploy-api.result == 'success' || needs.deploy-api.result == 'skipped') &&
      ( inputs.environment != 'testing' ) &&
      inputs.deploy_pro == true
    uses: ./.github/workflows/dev_on_workflow_configure_live_channel_pro_generic.yml
    secrets:
      GCP_EHP_SERVICE_ACCOUNT: ${{ secrets.GCP_EHP_SERVICE_ACCOUNT }}
      GCP_EHP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_EHP_WORKLOAD_IDENTITY_PROVIDER }}
    with:
      ENV: ${{ inputs.environment }}
      VERSION: ${{ inputs.app_version }}

  apply-algolia-config:
    name: "apply Algolia settings"
    needs: deploy-api
    if: |
      (inputs.environment == 'staging' || inputs.environment == 'production') &&
      (needs.deploy-api.result == 'success' || needs.deploy-api.result == 'skipped')
    environment: ${{ inputs.environment }}
    permissions:
      id-token: write
      contents: read
    runs-on: ubuntu-latest
    steps:
      - name: "Install Teleport"
        uses: teleport-actions/setup@v1
        with:
          version: ${{ inputs.teleport_version }}
      - name: "Teleport Authentication"
        id: "teleport-auth"
        uses: teleport-actions/auth-k8s@v1
        with:
          proxy: ${{ inputs.teleport_proxy }}
          token: github-token
          certificate-ttl: 1h
          kubernetes-cluster: ${{ inputs.teleport_kubernetes_cluster }}
      - name: "Configure algolia"
        id: "set_algolia_settings"
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 30
          max_attempts: 3
          command: |
            POD_NAME=$(kubectl -n ${{ inputs.environment }} get po -l role=api -o json |jq -r '.items[] | select(.spec.containers[0].image | contains("${{ inputs.app_version }}")) | "\(.metadata.name)"'|head -n 1)
            echo "flask commands runs on ${POD_NAME}"
            kubectl exec -it -n ${{ inputs.environment }} --field-selector=status.phase==Running ${POD_NAME} -- flask set_algolia_settings offers --dry-run=false
            kubectl exec -it -n ${{ inputs.environment }} --field-selector=status.phase==Running ${POD_NAME} -- flask set_algolia_settings collective_offers --dry-run=false
            kubectl exec -it -n ${{ inputs.environment }} --field-selector=status.phase==Running ${POD_NAME} -- flask set_algolia_settings venues --dry-run=false

  deploy-image-resizing-ehp:
    name: "Deploy image-resizing EHP"
    permissions:
      contents: 'read'
      id-token: 'write'
    uses: ./.github/workflows/dev_on_workflow_deploy_app_engine_image_resizing.yml
    if: ${{ inputs.environment != 'production' }}
    with:
      workload_identity_provider_secret_name: passculture-metier-ehp/gcp_metier_ehp_workload_identity_provider
      service_account_secret_name: passculture-metier-ehp/app_engine_image_resizing_service_account
      image_resizing_url: https://image-resizing.testing.passculture.team
      environment: testing
      google_project: passculture-metier-ehp
      base_ref: ${{ github.ref }}
    secrets:
      GCP_EHP_SERVICE_ACCOUNT: ${{ secrets.GCP_EHP_SERVICE_ACCOUNT }}
      GCP_EHP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_EHP_WORKLOAD_IDENTITY_PROVIDER }}

  deploy-image-resizing-production:
    name: "Deploy image-resizing production"
    permissions:
      contents: 'read'
      id-token: 'write'
    uses: ./.github/workflows/dev_on_workflow_deploy_app_engine_image_resizing.yml
    if: ${{ inputs.environment == 'production' }}
    with:
      workload_identity_provider_secret_name: passculture-metier-ehp/gcp_metier_prod_workload_identity_provider
      service_account_secret_name: passculture-metier-ehp/app_engine_prod_image_resizing_service_account
      image_resizing_url: https://image-resizing.passculture.app
      environment: production
      google_project: passculture-metier-prod
      base_ref: ${{ github.ref }}
    secrets:
      GCP_EHP_SERVICE_ACCOUNT: ${{ secrets.GCP_EHP_SERVICE_ACCOUNT }}
      GCP_EHP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_EHP_WORKLOAD_IDENTITY_PROVIDER }}
