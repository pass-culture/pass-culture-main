import Package from '../../package.json'

export interface ApiErrorResonseMessages {
  global?: string[]
  [key: string]: string[] | undefined
}

export class ApiError extends Error {
  name = 'ApiError'
  content: any
  statusCode: number

  constructor(
    statusCode: number,
    content: ApiErrorResonseMessages,
    message?: string
  ) {
    super(message)
    this.content = content
    this.statusCode = statusCode
  }
}

export const HTTP_STATUS = {
  NO_CONTENT: 204,
  FORBIDDEN: 403,
  SERVICE_UNAVAILABLE: 503,
  GATEWAY_TIMEOUT: 504,
  TOO_MANY_REQUESTS: 429,
  GONE: 410,
  NOT_FOUND: 404,
}

export const safeFetch = async (
  url: string,
  options: RequestInit
): Promise<Response> => {
  const params = new URLSearchParams(window.location.search)
  const token = params.get('token')
  const runtimeOptions: RequestInit = {
    ...options,
    headers: {
      ...options.headers,
      'app-version': Package.version,
      ['Authorization']: `Bearer ${token}`,
    },
  }

  return await fetch(url, { ...runtimeOptions, credentials: 'same-origin' })
}

// In this case, the following `any` is not that much of a problem in the context of usage
// with the autogenerated files of swagger-codegen.
// !!! Not encouraging to use `any` anywhere else !!!
export async function handleGeneratedApiResponse(
  response: Response
): Promise<any | void> {
  if (
    response.status === HTTP_STATUS.NO_CONTENT ||
    response.status === HTTP_STATUS.SERVICE_UNAVAILABLE
  ) {
    return {}
  }
  const responseBody = await response.json()
  if (!response.ok) {
    throw new ApiError(
      response.status,
      await responseBody,
      `Échec de la requête ${response.url}, code: ${response.status}`
    )
  }

  return await responseBody
}
