/// <reference path="./custom.d.ts" />
// tslint:disable
/* eslint-disable */
/**
 * pass Culture pro private API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */
import url from 'url'

// TODO: ModelObject should be removed when offer.extraData is correctly typed on api
import {
  EmptyResponse,
  ModelObject,
  handleGeneratedApiResponse,
  safeFetch,
} from 'api/helpers'

import { APIConfiguration } from './configuration'

const BASE_PATH = '/'.replace(/\/+$/, '')

export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
}

export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

export interface FetchArgs {
  url: string
  options: any
}

export class BaseAPI {
  protected configuration?: APIConfiguration
  constructor(
    configuration?: APIConfiguration,
    protected basePath: string = BASE_PATH
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    }
  }
}

export class RequiredError extends Error {
  name = 'RequiredError'
  constructor(public field: string, msg?: string) {
    super(msg)
  }
}

export interface BannerMetaModel {
  imageCredit?: string | null
}

export enum BookingStatusFilter {
  Booked = 'booked',
  Validated = 'validated',
  Reimbursed = 'reimbursed',
}
export interface BookingRecapResponseBeneficiaryModel {
  email?: string | null
  firstname?: string | null
  lastname?: string | null
  phonenumber?: string | null
}

export interface BookingRecapResponseBookingStatusHistoryModel {
  date?: Date | null
  status: BookingRecapStatus
}

export interface BookingRecapResponseModel {
  beneficiary: BookingRecapResponseBeneficiaryModel
  bookingAmount: number
  bookingDate: Date
  bookingIsDuo: boolean
  bookingStatus: BookingRecapStatus
  bookingStatusHistory: Array<BookingRecapResponseBookingStatusHistoryModel>
  bookingToken?: string | null
  stock: BookingRecapResponseStockModel
}

export interface BookingRecapResponseStockModel {
  eventBeginningDatetime?: Date | null
  offerIdentifier: string
  offerIsEducational: boolean
  offerIsbn?: string | null
  offerName: string
}

export enum BookingRecapStatus {
  Booked = 'booked',
  Validated = 'validated',
  Cancelled = 'cancelled',
  Reimbursed = 'reimbursed',
  Confirmed = 'confirmed',
  Pending = 'pending',
}

export interface BusinessUnitEditionBodyModel {
  siret: string
}

export interface BusinessUnitListQueryModel {
  offererId?: number | null
}

export interface BusinessUnitListResponseModel
  extends Array<BusinessUnitResponseModel> {}

export interface BusinessUnitResponseModel {
  bic?: string | null
  iban?: string | null
  id: number
  name: string
  siret?: string | null
}

export interface CategoriesResponseModel {
  categories: Array<CategoryResponseModel>
  subcategories: Array<SubcategoryResponseModel>
}

export interface CategoryResponseModel {
  id: string
  isSelectable: boolean
  proLabel: string
}

export interface CollectiveOfferExtraDataOfferVenueBodyModel {
  addressType: OfferAddressType
  otherAddress: string
  venueId: string
}

export interface CollectiveOfferOfferVenueResponseModel {
  addressType: OfferAddressType
  otherAddress: string
  venueId: string
}

export interface CollectiveOfferResponseIdModel {
  id: string
}

export interface CollectiveOfferResponseModel {
  hasBookingLimitDatetimesPassed: boolean
  id: string
  isActive: boolean
  isEditable: boolean
  isEducational: boolean
  isEvent: boolean
  isShowcase?: boolean | null
  isThing: boolean
  name: string
  offerId?: string | null
  productIsbn?: string | null
  status: string
  stocks: Array<CollectiveOffersStockResponseModel>
  subcategoryId: SubcategoryIdEnum
  thumbUrl?: string | null
  venue: ListOffersVenueResponseModel
  venueId: string
}

export interface CollectiveOffersStockResponseModel {
  beginningDatetime?: Date | null
  hasBookingLimitDatetimePassed: boolean
  id: string
  offerId: string
  remainingQuantity: number | string
}
export interface CreateOffererQueryModel {
  address?: string | null
  city: string
  latitude?: number | null
  longitude?: number | null
  name: string
  postalCode: string
  siren: string
}

export interface CreateThumbnailResponseModel {
  id: string
}

export interface EditVenueBodyModel {
  address?: string | null
  audioDisabilityCompliant?: boolean | null
  bookingEmail?: string | null
  businessUnitId?: number | null
  city?: string | null
  comment?: string | null
  contact?: VenueContactModel | null
  description?: string | null
  isAccessibilityAppliedOnAllOffers?: boolean | null
  isEmailAppliedOnAllOffers?: boolean | null
  isWithdrawalAppliedOnAllOffers?: boolean | null
  latitude?: number | string | null
  longitude?: number | string | null
  mentalDisabilityCompliant?: boolean | null
  motorDisabilityCompliant?: boolean | null
  name?: string | null
  postalCode?: string | null
  publicName?: string | null
  siret?: string | null
  venueLabelId?: number | null
  venueTypeCode?: string | null
  visualDisabilityCompliant?: boolean | null
  withdrawalDetails?: string | null
}

export interface EducationalOfferExtraDataOfferVenueBodyModel {
  addressType: OfferAddressType
  otherAddress: string
  venueId: string
}

export interface EducationalOfferPartialExtraDataBodyModel {
  contactEmail?: string | null
  contactPhone?: string | null
  offerVenue?: EducationalOfferExtraDataOfferVenueBodyModel | null
  students?: Array<string> | null
}

export interface EducationalStockCreationBodyModel {
  beginningDatetime: Date
  bookingLimitDatetime?: Date | null
  educationalPriceDetail?: string | null
  numberOfTickets: number
  offerId: number
  totalPrice: number
}

export interface EducationalStockEditionBodyModel {
  beginningDatetime?: Date | null
  bookingLimitDatetime?: Date | null
  educationalPriceDetail?: string | null
  numberOfTickets?: number | null
  totalPrice?: number | null
}

export interface FeatureResponseModel {
  description: string
  id: string
  isActive: boolean
  name: string
  nameKey: string
}

export enum GenderEnum {
  M = 'M.',
  Mme = 'Mme',
}
export interface GenerateOffererApiKeyResponse {
  apiKey: string
}

export interface GetEducationalOffererResponseModel {
  id: string
  managedVenues: Array<GetEducationalOffererVenueResponseModel>
  name: string
}

export interface GetEducationalOffererVenueResponseModel {
  address?: string | null
  audioDisabilityCompliant?: boolean | null
  city?: string | null
  id: string
  isVirtual: boolean
  mentalDisabilityCompliant?: boolean | null
  motorDisabilityCompliant?: boolean | null
  name: string
  postalCode?: string | null
  publicName?: string | null
  visualDisabilityCompliant?: boolean | null
}

export interface GetEducationalOfferersQueryModel {
  offererId?: string | null
}

export interface GetEducationalOfferersResponseModel {
  educationalOfferers: Array<GetEducationalOffererResponseModel>
}

export interface GetOfferLastProviderResponseModel {
  enabledForPro: boolean
  id: string
  isActive: boolean
  localClass?: string | null
  name: string
}

export interface GetOfferManagingOffererResponseModel {
  address?: string | null
  city: string
  dateCreated: Date
  dateModifiedAtLastProvider?: Date | null
  fieldsUpdated: Array<string>
  id: string
  idAtProviders?: string | null
  isActive: boolean
  isValidated: boolean
  lastProviderId?: string | null
  name: string
  postalCode: string
  siren?: string | null
  thumbCount: number
}

export interface GetOfferMediationResponseModel {
  authorId?: string | null
  credit?: string | null
  dateCreated: Date
  dateModifiedAtLastProvider?: Date | null
  fieldsUpdated: Array<string>
  id: string
  idAtProviders?: string | null
  isActive: boolean
  lastProviderId?: string | null
  offerId: string
  thumbCount: number
  thumbUrl?: string | null
}

export interface GetOfferProductResponseModel {
  ageMax?: number | null
  ageMin?: number | null
  conditions?: string | null
  dateModifiedAtLastProvider?: Date | null
  description?: string | null
  durationMinutes?: number | null
  extraData?: ModelObject | null
  fieldsUpdated: Array<string>
  id: string
  idAtProviders?: string | null
  isGcuCompatible: boolean
  isNational: boolean
  lastProviderId?: string | null
  mediaUrls: Array<string>
  name: string
  owningOffererId?: string | null
  thumbCount: number
  url?: string | null
}

export interface GetOfferResponseModel {
  activeMediation?: GetOfferMediationResponseModel | null
  ageMax?: number | null
  ageMin?: number | null
  audioDisabilityCompliant?: boolean | null
  bookingEmail?: string | null
  conditions?: string | null
  dateCreated: Date
  dateModifiedAtLastProvider?: Date | null
  dateRange: Array<Date>
  description?: string | null
  durationMinutes?: number | null
  externalTicketOfficeUrl?: string | null
  extraData?: ModelObject | null
  fieldsUpdated: Array<string>
  hasBookingLimitDatetimesPassed: boolean
  id: string
  isActive: boolean
  isBookable: boolean
  isDigital: boolean
  isDuo: boolean
  isEditable: boolean
  isEducational: boolean
  isEvent: boolean
  isNational: boolean
  isThing: boolean
  lastProvider?: GetOfferLastProviderResponseModel | null
  lastProviderId?: string | null
  mediaUrls: Array<string>
  mediations: Array<GetOfferMediationResponseModel>
  mentalDisabilityCompliant?: boolean | null
  motorDisabilityCompliant?: boolean | null
  name: string
  nonHumanizedId: number
  product: GetOfferProductResponseModel
  productId: string
  status: OfferStatus
  stocks: Array<GetOfferStockResponseModel>
  subcategoryId: SubcategoryIdEnum
  thumbUrl?: string | null
  url?: string | null
  venue: GetOfferVenueResponseModel
  venueId: string
  visualDisabilityCompliant?: boolean | null
  withdrawalDetails?: string | null
}

export interface GetOfferStockResponseModel {
  beginningDatetime?: Date | null
  bookingLimitDatetime?: Date | null
  bookingsQuantity: number
  cancellationLimitDate?: Date | null
  dateCreated: Date
  dateModified: Date
  dateModifiedAtLastProvider?: Date | null
  fieldsUpdated: Array<string>
  hasActivationCode: boolean
  id: string
  idAtProviders?: string | null
  isBookable: boolean
  isEventDeletable: boolean
  isEventExpired: boolean
  isSoftDeleted: boolean
  lastProviderId?: string | null
  offerId: string
  price: number
  quantity?: number | null
  remainingQuantity?: number | string | null
}

export interface GetOfferVenueResponseModel {
  address?: string | null
  audioDisabilityCompliant?: boolean | null
  bookingEmail?: string | null
  city?: string | null
  comment?: string | null
  dateCreated?: Date | null
  dateModifiedAtLastProvider?: Date | null
  departementCode?: string | null
  fieldsUpdated: Array<string>
  id: string
  idAtProviders?: string | null
  isValidated: boolean
  isVirtual: boolean
  lastProviderId?: string | null
  latitude?: number | null
  longitude?: number | null
  managingOfferer: GetOfferManagingOffererResponseModel
  managingOffererId: string
  mentalDisabilityCompliant?: boolean | null
  motorDisabilityCompliant?: boolean | null
  name: string
  postalCode?: string | null
  publicName?: string | null
  siret?: string | null
  thumbCount: number
  venueLabelId?: string | null
  visualDisabilityCompliant?: boolean | null
}

export interface GetOffererListQueryModel {
  keywords?: string | null
  page?: number | null
  paginate?: number | null
}

export interface GetOffererNameResponseModel {
  id: string
  name: string
}

export interface GetOffererResponseModel {
  address?: string | null
  apiKey: OffererApiKey
  bic?: string | null
  city: string
  dateCreated: Date
  dateModifiedAtLastProvider?: Date | null
  demarchesSimplifieesApplicationId?: string | null
  fieldsUpdated: Array<string>
  hasDigitalVenueAtLeastOneOffer: boolean
  hasMissingBankInformation: boolean
  iban?: string | null
  id: string
  idAtProviders?: string | null
  isActive: boolean
  isValidated: boolean
  lastProviderId?: string | null
  managedVenues: Array<GetOffererVenueResponseModel>
  name: string
  postalCode: string
  siren?: string | null
}

export interface GetOffererVenueResponseModel {
  address?: string | null
  audioDisabilityCompliant?: boolean | null
  bookingEmail?: string | null
  businessUnitId?: number | null
  city?: string | null
  comment?: string | null
  departementCode?: string | null
  id: string
  isValidated: boolean
  isVirtual: boolean
  managingOffererId: string
  mentalDisabilityCompliant?: boolean | null
  motorDisabilityCompliant?: boolean | null
  name: string
  postalCode?: string | null
  publicName?: string | null
  venueLabelId?: string | null
  visualDisabilityCompliant?: boolean | null
  withdrawalDetails?: string | null
}

export interface GetOfferersListResponseModel {
  nbTotalResults: number
  offerers: Array<GetOfferersResponseModel>
}

export interface GetOfferersNamesQueryModel {
  validated?: boolean | null
  validatedForUser?: boolean | null
}

export interface GetOfferersNamesResponseModel {
  offerersNames: Array<GetOffererNameResponseModel>
}

export interface GetOfferersResponseModel {
  id: string
  isValidated: boolean
  managedVenues: Array<GetOfferersVenueResponseModel>
  nOffers: number
  name: string
  siren?: string | null
  userHasAccess: boolean
}

export interface GetOfferersVenueResponseModel {
  id: string
  isVirtual: boolean
}

export interface GetVenueManagingOffererResponseModel {
  address?: string | null
  bic?: string | null
  city: string
  dateCreated: Date
  dateModifiedAtLastProvider?: Date | null
  demarchesSimplifieesApplicationId?: string | null
  fieldsUpdated: Array<string>
  iban?: string | null
  id: string
  idAtProviders?: string | null
  isValidated: boolean
  lastProviderId?: string | null
  name: string
  postalCode: string
  siren?: string | null
}

export interface GetVenueResponseModel {
  address?: string | null
  audioDisabilityCompliant?: boolean | null
  bannerMeta?: BannerMetaModel | null
  bannerUrl?: string | null
  bic?: string | null
  bookingEmail?: string | null
  businessUnit?: BusinessUnitResponseModel | null
  businessUnitId?: number | null
  city?: string | null
  comment?: string | null
  contact?: VenueContactModel | null
  dateCreated: Date
  dateModifiedAtLastProvider?: Date | null
  demarchesSimplifieesApplicationId?: string | null
  departementCode?: string | null
  description?: string | null
  fieldsUpdated: Array<string>
  iban?: string | null
  id: string
  idAtProviders?: string | null
  isBusinessUnitMainVenue?: boolean | null
  isPermanent?: boolean | null
  isValidated: boolean
  isVirtual: boolean
  lastProviderId?: string | null
  latitude?: number | null
  longitude?: number | null
  managingOfferer: GetVenueManagingOffererResponseModel
  managingOffererId: string
  mentalDisabilityCompliant?: boolean | null
  motorDisabilityCompliant?: boolean | null
  name: string
  nonHumanizedId: number
  postalCode?: string | null
  publicName?: string | null
  siret?: string | null
  venueLabelId?: string | null
  venueTypeCode?: VenueTypeCode | null
  visualDisabilityCompliant?: boolean | null
  withdrawalDetails?: string | null
}

export interface InvoiceListQueryModel {
  businessUnitId?: number | null
  periodBeginningDate?: string | null
  periodEndingDate?: string | null
}

export interface InvoiceListResponseModel extends Array<InvoiceResponseModel> {}

export interface InvoiceResponseModel {
  amount: number
  businessUnitName: string
  date: string
  reference: string
  url: string
}

export interface ListBookingsQueryModel {
  bookingPeriodBeginningDate?: string | null
  bookingPeriodEndingDate?: string | null
  bookingStatusFilter?: BookingStatusFilter | null
  eventDate?: string | null
  extra?: string
  offerType?: OfferType | null
  page?: number
  venueId?: number | null
}

export interface ListBookingsResponseModel {
  bookingsRecap: Array<BookingRecapResponseModel>
  page: number
  pages: number
  total: number
}

export interface ListCollectiveOffersQueryModel {
  categoryId?: string | null
  creationMode?: string | null
  nameOrIsbn?: string | null
  offererId?: number | null
  periodBeginningDate?: string | null
  periodEndingDate?: string | null
  status?: string | null
  venueId?: number | null
}

export interface ListCollectiveOffersResponseModel
  extends Array<CollectiveOfferResponseModel> {}

export interface ListFeatureResponseModel extends Array<FeatureResponseModel> {}

export interface ListOffersOfferResponseModel {
  hasBookingLimitDatetimesPassed: boolean
  id: string
  isActive: boolean
  isEditable: boolean
  isEducational: boolean
  isEvent: boolean
  isShowcase?: boolean | null
  isThing: boolean
  name: string
  productIsbn?: string | null
  status: string
  stocks: Array<ListOffersStockResponseModel>
  subcategoryId: SubcategoryIdEnum
  thumbUrl?: string | null
  venue: ListOffersVenueResponseModel
  venueId: string
}

export interface ListOffersQueryModel {
  categoryId?: string | null
  creationMode?: string | null
  nameOrIsbn?: string | null
  offererId?: number | null
  periodBeginningDate?: string | null
  periodEndingDate?: string | null
  status?: string | null
  venueId?: number | null
}

export interface ListOffersResponseModel
  extends Array<ListOffersOfferResponseModel> {}

export interface ListOffersStockResponseModel {
  beginningDatetime?: Date | null
  hasBookingLimitDatetimePassed: boolean
  id: string
  offerId: string
  remainingQuantity: number | string
}

export interface ListOffersVenueResponseModel {
  departementCode?: string | null
  id: string
  isVirtual: boolean
  managingOffererId: string
  name: string
  offererName: string
  publicName?: string | null
}

export interface ListProviderResponse extends Array<ProviderResponse> {}

export interface ListUserOfferersResponseModel
  extends Array<UserOffererResponseModel> {}

export interface ListVenueProviderQuery {
  venueId: number
}

export interface ListVenueProviderResponse {
  venueProviders: Array<VenueProviderResponse>
}

export interface LoginUserBodyModel {
  identifier: string
  password: string
}

export enum OfferAddressType {
  OffererVenue = 'offererVenue',
  School = 'school',
  Other = 'other',
}
export interface OfferResponseIdModel {
  id: string
}

export enum OfferStatus {
  ACTIVE = 'ACTIVE',
  PENDING = 'PENDING',
  EXPIRED = 'EXPIRED',
  REJECTED = 'REJECTED',
  SOLDOUT = 'SOLD_OUT',
  INACTIVE = 'INACTIVE',
  DRAFT = 'DRAFT',
}
export interface OfferType {}

export interface OffererApiKey {
  maxAllowed: number
  prefixes: Array<string>
}

export interface PatchAllOffersActiveStatusBodyModel {
  categoryId?: string | null
  creationMode?: string | null
  isActive: boolean
  nameOrIsbn?: string | null
  offererId?: number | null
  periodBeginningDate?: Date | null
  periodEndingDate?: Date | null
  status?: string | null
  venueId?: number | null
}

export interface PatchEducationalOfferBodyModel {
  audioDisabilityCompliant?: boolean | null
  bookingEmail?: string | null
  description?: string | null
  durationMinutes?: number | null
  extraData?: EducationalOfferPartialExtraDataBodyModel | null
  mentalDisabilityCompliant?: boolean | null
  motorDisabilityCompliant?: boolean | null
  name?: string | null
  subcategoryId?: SubcategoryIdEnum | null
  visualDisabilityCompliant?: boolean | null
}

export interface PatchOfferActiveStatusBodyModel {
  ids: Array<number>
  isActive: boolean
}

export interface PatchOfferBodyModel {
  ageMax?: number | null
  ageMin?: number | null
  audioDisabilityCompliant?: boolean | null
  bookingEmail?: string | null
  conditions?: string | null
  description?: string | null
  durationMinutes?: number | null
  externalTicketOfficeUrl?: string | null
  extraData?: ModelObject | null
  isActive?: boolean | null
  isDuo?: boolean | null
  isNational?: boolean | null
  mediaUrls?: Array<string> | null
  mentalDisabilityCompliant?: boolean | null
  motorDisabilityCompliant?: boolean | null
  name?: string | null
  productId?: string | null
  url?: string | null
  venueId?: string | null
  visualDisabilityCompliant?: boolean | null
  withdrawalDetails?: string | null
}

export interface PatchProUserBodyModel {
  email?: string | null
  firstName?: string | null
  lastName?: string | null
  phoneNumber?: string | null
}

export interface PatchProUserResponseModel {
  email: string
  firstName?: string | null
  lastName?: string | null
  phoneNumber?: string | null
}

export enum PhoneValidationStatusType {
  BlockedTooManyCodeSendings = 'blocked-too-many-code-sendings',
  BlockedTooManyCodeVerificationTries = 'blocked-too-many-code-verification-tries',
  Validated = 'validated',
}
export interface PostCollectiveOfferBodyModel {
  audioDisabilityCompliant?: boolean
  bookingEmail?: string | null
  contactEmail: string
  contactPhone: string
  description?: string | null
  durationMinutes?: number | null
  mentalDisabilityCompliant?: boolean
  motorDisabilityCompliant?: boolean
  name: string
  offerVenue: CollectiveOfferExtraDataOfferVenueBodyModel
  offererId: string
  students: Array<StudentLevels>
  subcategoryId: string
  venueId: string
  visualDisabilityCompliant?: boolean
}

export interface PostEducationalOfferBodyModel {
  audioDisabilityCompliant?: boolean
  bookingEmail?: string | null
  description?: string | null
  durationMinutes?: number | null
  extraData: PostEducationalOfferExtraDataBodyModel
  mentalDisabilityCompliant?: boolean
  motorDisabilityCompliant?: boolean
  name: string
  offererId: string
  subcategoryId: string
  venueId: string
  visualDisabilityCompliant?: boolean
}

export interface PostEducationalOfferExtraDataBodyModel {
  contactEmail: string
  contactPhone: string
  offerVenue: EducationalOfferExtraDataOfferVenueBodyModel
  students: Array<StudentLevels>
}

export interface PostOfferBodyModel {
  ageMax?: number | null
  ageMin?: number | null
  audioDisabilityCompliant?: boolean
  bookingEmail?: string | null
  conditions?: string | null
  description?: string | null
  durationMinutes?: number | null
  externalTicketOfficeUrl?: string | null
  extraData?: ModelObject | null
  isDuo?: boolean | null
  isEducational?: boolean | null
  isNational?: boolean | null
  mediaUrls?: Array<string> | null
  mentalDisabilityCompliant?: boolean
  motorDisabilityCompliant?: boolean
  name?: string | null
  offererId?: string | null
  productId?: string | null
  subcategoryId?: string | null
  url?: string | null
  venueId: string
  visualDisabilityCompliant?: boolean
  withdrawalDetails?: string | null
}

export interface PostVenueProviderBody {
  isDuo?: boolean
  price?: string
  providerId: string
  quantity?: number
  venueId: string
  venueIdAtOfferProvider?: string
}

export interface ProviderResponse {
  enabledForPro: boolean
  id: string
  isActive: boolean
  localClass?: string
  name: string
}

export interface ReimbursementCsvQueryModel {
  reimbursementPeriodBeginningDate?: string
  reimbursementPeriodEndingDate?: string
  venueId?: string
}

export interface SharedCurrentUserResponseModel {
  activity?: string | null
  address?: string | null
  city?: string | null
  civility?: GenderEnum | null
  dateCreated: Date
  dateOfBirth?: Date | null
  departementCode?: string | null
  email: string
  externalIds?: any | null
  firstName?: string | null
  hasPhysicalVenues?: boolean | null
  hasSeenProTutorials?: boolean | null
  id: string
  idPieceNumber?: string | null
  isAdmin: boolean
  isEmailValidated: boolean
  lastConnectionDate?: Date | null
  lastName?: string | null
  needsToFillCulturalSurvey?: boolean | null
  notificationSubscriptions?: any | null
  phoneNumber?: string | null
  phoneValidationStatus?: PhoneValidationStatusType | null
  postalCode?: string | null
  publicName?: string | null
  roles: Array<UserRole>
}

export interface SharedLoginUserResponseModel {
  activity?: string | null
  address?: string | null
  city?: string | null
  civility?: GenderEnum | null
  dateCreated: Date
  dateOfBirth?: Date | null
  departementCode?: string | null
  email: string
  firstName?: string | null
  hasPhysicalVenues?: boolean | null
  hasSeenProTutorials?: boolean | null
  id: string
  isAdmin: boolean
  isEmailValidated: boolean
  lastConnectionDate?: Date | null
  lastName?: string | null
  needsToFillCulturalSurvey?: boolean | null
  phoneNumber?: string | null
  postalCode?: string | null
  publicName?: string | null
  roles: Array<UserRole>
}

export interface StockCreationBodyModel {
  activationCodes?: Array<string> | null
  activationCodesExpirationDatetime?: Date | null
  beginningDatetime?: Date | null
  bookingLimitDatetime?: Date | null
  price: number
  quantity?: number | null
}

export interface StockEditionBodyModel {
  beginningDatetime?: Date | null
  bookingLimitDatetime?: Date | null
  id: number
  price: number
  quantity?: number | null
}

export interface StockIdResponseModel {
  id: string
}

export interface StockIdsResponseModel {
  stockIds: Array<StockIdResponseModel>
}

export interface StockResponseModel {
  activationCodesExpirationDatetime?: Date | null
  beginningDatetime?: Date | null
  bookingLimitDatetime?: Date | null
  bookingsQuantity: number
  dateCreated: Date
  dateModified: Date
  educationalPriceDetail?: string | null
  hasActivationCodes: boolean
  id: string
  isEducationalStockEditable?: boolean | null
  isEventDeletable: boolean
  isEventExpired: boolean
  numberOfTickets?: number | null
  offerId: string
  price: number
  quantity?: number | null
}

export interface StocksResponseModel {
  stocks: Array<StockResponseModel>
}

export interface StocksUpsertBodyModel {
  offerId: number
  stocks: Array<StockCreationBodyModel | StockEditionBodyModel>
}

export enum StudentLevels {
  Collge4e = 'Collège - 4e',
  Collge3e = 'Collège - 3e',
  CAP1reAnne = 'CAP - 1re année',
  CAP2eAnne = 'CAP - 2e année',
  LyceSeconde = 'Lycée - Seconde',
  LycePremire = 'Lycée - Première',
  LyceTerminale = 'Lycée - Terminale',
}
export enum SubcategoryIdEnum {
  ABOBIBLIOTHEQUE = 'ABO_BIBLIOTHEQUE',
  ABOCONCERT = 'ABO_CONCERT',
  ABOJEUVIDEO = 'ABO_JEU_VIDEO',
  ABOLIVRENUMERIQUE = 'ABO_LIVRE_NUMERIQUE',
  ABOLUDOTHEQUE = 'ABO_LUDOTHEQUE',
  ABOMEDIATHEQUE = 'ABO_MEDIATHEQUE',
  ABOMUSEE = 'ABO_MUSEE',
  ABOPLATEFORMEMUSIQUE = 'ABO_PLATEFORME_MUSIQUE',
  ABOPLATEFORMEVIDEO = 'ABO_PLATEFORME_VIDEO',
  ABOPRATIQUEART = 'ABO_PRATIQUE_ART',
  ABOPRESSEENLIGNE = 'ABO_PRESSE_EN_LIGNE',
  ABOSPECTACLE = 'ABO_SPECTACLE',
  ACHATINSTRUMENT = 'ACHAT_INSTRUMENT',
  ACTIVATIONEVENT = 'ACTIVATION_EVENT',
  ACTIVATIONTHING = 'ACTIVATION_THING',
  APPCULTURELLE = 'APP_CULTURELLE',
  ATELIERPRATIQUEART = 'ATELIER_PRATIQUE_ART',
  AUTRESUPPORTNUMERIQUE = 'AUTRE_SUPPORT_NUMERIQUE',
  BONACHATINSTRUMENT = 'BON_ACHAT_INSTRUMENT',
  CAPTATIONMUSIQUE = 'CAPTATION_MUSIQUE',
  CARTECINEILLIMITE = 'CARTE_CINE_ILLIMITE',
  CARTECINEMULTISEANCES = 'CARTE_CINE_MULTISEANCES',
  CARTEJEUNES = 'CARTE_JEUNES',
  CARTEMUSEE = 'CARTE_MUSEE',
  CINEPLEINAIR = 'CINE_PLEIN_AIR',
  CINEVENTEDISTANCE = 'CINE_VENTE_DISTANCE',
  CONCERT = 'CONCERT',
  CONCOURS = 'CONCOURS',
  CONFERENCE = 'CONFERENCE',
  DECOUVERTEMETIERS = 'DECOUVERTE_METIERS',
  ESCAPEGAME = 'ESCAPE_GAME',
  EVENEMENTCINE = 'EVENEMENT_CINE',
  EVENEMENTJEU = 'EVENEMENT_JEU',
  EVENEMENTMUSIQUE = 'EVENEMENT_MUSIQUE',
  EVENEMENTPATRIMOINE = 'EVENEMENT_PATRIMOINE',
  FESTIVALCINE = 'FESTIVAL_CINE',
  FESTIVALLIVRE = 'FESTIVAL_LIVRE',
  FESTIVALMUSIQUE = 'FESTIVAL_MUSIQUE',
  FESTIVALSPECTACLE = 'FESTIVAL_SPECTACLE',
  JEUENLIGNE = 'JEU_EN_LIGNE',
  JEUSUPPORTPHYSIQUE = 'JEU_SUPPORT_PHYSIQUE',
  LIVESTREAMEVENEMENT = 'LIVESTREAM_EVENEMENT',
  LIVESTREAMMUSIQUE = 'LIVESTREAM_MUSIQUE',
  LIVESTREAMPRATIQUEARTISTIQUE = 'LIVESTREAM_PRATIQUE_ARTISTIQUE',
  LIVREAUDIOPHYSIQUE = 'LIVRE_AUDIO_PHYSIQUE',
  LIVRENUMERIQUE = 'LIVRE_NUMERIQUE',
  LIVREPAPIER = 'LIVRE_PAPIER',
  LOCATIONINSTRUMENT = 'LOCATION_INSTRUMENT',
  MATERIELARTCREATIF = 'MATERIEL_ART_CREATIF',
  MUSEEVENTEDISTANCE = 'MUSEE_VENTE_DISTANCE',
  OEUVREART = 'OEUVRE_ART',
  PARTITION = 'PARTITION',
  PLATEFORMEPRATIQUEARTISTIQUE = 'PLATEFORME_PRATIQUE_ARTISTIQUE',
  PRATIQUEARTVENTEDISTANCE = 'PRATIQUE_ART_VENTE_DISTANCE',
  PODCAST = 'PODCAST',
  RENCONTREENLIGNE = 'RENCONTRE_EN_LIGNE',
  RENCONTREJEU = 'RENCONTRE_JEU',
  RENCONTRE = 'RENCONTRE',
  SALON = 'SALON',
  SEANCECINE = 'SEANCE_CINE',
  SEANCEESSAIPRATIQUEART = 'SEANCE_ESSAI_PRATIQUE_ART',
  SPECTACLEENREGISTRE = 'SPECTACLE_ENREGISTRE',
  SPECTACLEREPRESENTATION = 'SPECTACLE_REPRESENTATION',
  SPECTACLEVENTEDISTANCE = 'SPECTACLE_VENTE_DISTANCE',
  SUPPORTPHYSIQUEFILM = 'SUPPORT_PHYSIQUE_FILM',
  SUPPORTPHYSIQUEMUSIQUE = 'SUPPORT_PHYSIQUE_MUSIQUE',
  TELECHARGEMENTLIVREAUDIO = 'TELECHARGEMENT_LIVRE_AUDIO',
  TELECHARGEMENTMUSIQUE = 'TELECHARGEMENT_MUSIQUE',
  VISITEGUIDEE = 'VISITE_GUIDEE',
  VISITEVIRTUELLE = 'VISITE_VIRTUELLE',
  VISITE = 'VISITE',
  VOD = 'VOD',
}
export interface SubcategoryResponseModel {
  appLabel: string
  canBeDuo: boolean
  canBeEducational: boolean
  canExpire: boolean
  categoryId: string
  conditionalFields: Array<string>
  id: string
  isDigitalDeposit: boolean
  isEvent: boolean
  isPhysicalDeposit: boolean
  isSelectable: boolean
  onlineOfflinePlatform: string
  proLabel: string
  reimbursementRule: string
  searchGroupName?: string | null
}

export interface UserOffererResponseModel {
  id: string
  offererId: string
  userId: string
}

export enum UserRole {
  ADMIN = 'ADMIN',
  BENEFICIARY = 'BENEFICIARY',
  PRO = 'PRO',
  UNDERAGEBENEFICIARY = 'UNDERAGE_BENEFICIARY',
}
export interface ValidationError extends Array<ValidationErrorElement> {}

export interface ValidationErrorElement {
  ctx?: any
  loc: Array<string>
  msg: string
  type: string
}

export interface VenueContactModel {
  email?: string | null
  phoneNumber?: string | null
  socialMedias?: { [key: string]: string } | null
  website?: string | null
}

export interface VenueLabelListResponseModel
  extends Array<VenueLabelResponseModel> {}

export interface VenueLabelResponseModel {
  id: string
  label: string
}

export interface VenueProviderResponse {
  dateModifiedAtLastProvider?: Date
  fieldsUpdated: Array<string>
  id: string
  idAtProviders?: string
  isActive: boolean
  isDuo?: boolean
  isFromAllocineProvider: boolean
  lastProviderId?: string
  lastSyncDate?: Date
  nOffers: number
  price?: number
  provider: ProviderResponse
  providerId: string
  quantity?: number
  venueId: string
  venueIdAtOfferProvider: string
}

export interface VenueStatsResponseModel {
  activeBookingsQuantity: number
  activeOffersCount: number
  soldOutOffersCount: number
  validatedBookingsQuantity: number
}

export enum VenueTypeCode {
  ArtsVisuelsArtsPlastiquesEtGaleries = 'Arts visuels, arts plastiques et galeries',
  CentreCulturel = 'Centre culturel',
  CoursEtPratiqueArtistiques = 'Cours et pratique artistiques',
  CultureScientifique = 'Culture scientifique',
  Festival = 'Festival',
  JeuxJeuxVidos = 'Jeux / Jeux vidéos',
  Librairie = 'Librairie',
  BibliothqueOuMdiathque = 'Bibliothèque ou médiathèque',
  Muse = 'Musée',
  MusiqueDisquaire = 'Musique - Disquaire',
  MusiqueMagasinDinstruments = 'Musique - Magasin d’instruments',
  MusiqueSalleDeConcerts = 'Musique - Salle de concerts',
  OffreNumrique = 'Offre numérique',
  PatrimoineEtTourisme = 'Patrimoine et tourisme',
  CinmaSalleDeProjections = 'Cinéma - Salle de projections',
  SpectacleVivant = 'Spectacle vivant',
  MagasinArtsCratifs = 'Magasin arts créatifs',
  LieuAdministratif = 'Lieu administratif',
  Autre = 'Autre',
}
export interface VenueTypeListResponseModel
  extends Array<VenueTypeResponseModel> {}

export interface VenueTypeResponseModel {
  id: string
  label: string
}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (
  configuration?: APIConfiguration
) {
  return {
    /**
     *
     * @summary delete_api_key <DELETE>
     * @param {string} apiKeyPrefix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOfferersDeleteApiKey(
      apiKeyPrefix: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'apiKeyPrefix' is not null or undefined
      if (apiKeyPrefix === null || apiKeyPrefix === undefined) {
        throw new RequiredError(
          'apiKeyPrefix',
          'Required parameter apiKeyPrefix was null or undefined when calling deleteOfferersDeleteApiKey.'
        )
      }
      const localVarPath = `/offerers/api_keys/{api_key_prefix}`.replace(
        `{${'api_key_prefix'}}`,
        encodeURIComponent(String(apiKeyPrefix))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'DELETE',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary delete_stock <DELETE>
     * @param {string} stockId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteStocksDeleteStock(
      stockId: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'stockId' is not null or undefined
      if (stockId === null || stockId === undefined) {
        throw new RequiredError(
          'stockId',
          'Required parameter stockId was null or undefined when calling deleteStocksDeleteStock.'
        )
      }
      const localVarPath = `/stocks/{stock_id}`.replace(
        `{${'stock_id'}}`,
        encodeURIComponent(String(stockId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'DELETE',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_bookings_pro <GET>
     * @param {number} [page]
     * @param {number} [venueId]
     * @param {string} [eventDate]
     * @param {BookingStatusFilter} [bookingStatusFilter]
     * @param {string} [bookingPeriodBeginningDate]
     * @param {string} [bookingPeriodEndingDate]
     * @param {OfferType} [offerType]
     * @param {string} [extra]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBookingsGetBookingsPro(
      page?: number,
      venueId?: number | null,
      eventDate?: string | null,
      bookingStatusFilter?: BookingStatusFilter,
      bookingPeriodBeginningDate?: string | null,
      bookingPeriodEndingDate?: string | null,
      offerType?: OfferType,
      extra?: string,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/bookings/pro`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }
      if (venueId !== undefined) {
        localVarQueryParameter['venueId'] = venueId
      }
      if (eventDate !== undefined) {
        localVarQueryParameter['eventDate'] = eventDate
      }
      if (bookingStatusFilter !== undefined) {
        localVarQueryParameter['bookingStatusFilter'] = bookingStatusFilter
      }
      if (bookingPeriodBeginningDate !== undefined) {
        localVarQueryParameter['bookingPeriodBeginningDate'] =
          bookingPeriodBeginningDate
      }
      if (bookingPeriodEndingDate !== undefined) {
        localVarQueryParameter['bookingPeriodEndingDate'] =
          bookingPeriodEndingDate
      }
      if (offerType !== undefined) {
        localVarQueryParameter['offerType'] = offerType
      }
      if (extra !== undefined) {
        localVarQueryParameter['extra'] = extra
      }
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary list_collective_offers <GET>
     * @param {string} [nameOrIsbn]
     * @param {number} [offererId]
     * @param {string} [status]
     * @param {number} [venueId]
     * @param {string} [categoryId]
     * @param {string} [creationMode]
     * @param {string} [periodBeginningDate]
     * @param {string} [periodEndingDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCollectiveListCollectiveOffers(
      nameOrIsbn?: string | null,
      offererId?: number | null,
      status?: string | null,
      venueId?: number | null,
      categoryId?: string | null,
      creationMode?: string | null,
      periodBeginningDate?: string | null,
      periodEndingDate?: string | null,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/collective/offers`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      if (nameOrIsbn !== undefined) {
        localVarQueryParameter['nameOrIsbn'] = nameOrIsbn
      }
      if (offererId !== undefined) {
        localVarQueryParameter['offererId'] = offererId
      }
      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }
      if (venueId !== undefined) {
        localVarQueryParameter['venueId'] = venueId
      }
      if (categoryId !== undefined) {
        localVarQueryParameter['categoryId'] = categoryId
      }
      if (creationMode !== undefined) {
        localVarQueryParameter['creationMode'] = creationMode
      }
      if (periodBeginningDate !== undefined) {
        localVarQueryParameter['periodBeginningDate'] = periodBeginningDate
      }
      if (periodEndingDate !== undefined) {
        localVarQueryParameter['periodEndingDate'] = periodEndingDate
      }
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary list_features <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFeaturesListFeatures(options: any = {}): Promise<FetchArgs> {
      const localVarPath = `/features`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_business_units <GET>
     * @param {number} [offererId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFinanceGetBusinessUnits(
      offererId?: number | null,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/finance/business-units`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      if (offererId !== undefined) {
        localVarQueryParameter['offererId'] = offererId
      }
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_invoices <GET>
     * @param {number} [businessUnitId]
     * @param {string} [periodBeginningDate]
     * @param {string} [periodEndingDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFinanceGetInvoices(
      businessUnitId?: number | null,
      periodBeginningDate?: string | null,
      periodEndingDate?: string | null,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/finance/invoices`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      if (businessUnitId !== undefined) {
        localVarQueryParameter['businessUnitId'] = businessUnitId
      }
      if (periodBeginningDate !== undefined) {
        localVarQueryParameter['periodBeginningDate'] = (
          periodBeginningDate as any
        ).toISOString()
      }
      if (periodEndingDate !== undefined) {
        localVarQueryParameter['periodEndingDate'] = (
          periodEndingDate as any
        ).toISOString()
      }
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary can_offerer_create_educational_offer <GET>
     * @param {string} humanizedOffererId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOfferersCanOffererCreateEducationalOffer(
      humanizedOffererId: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'humanizedOffererId' is not null or undefined
      if (humanizedOffererId === null || humanizedOffererId === undefined) {
        throw new RequiredError(
          'humanizedOffererId',
          'Required parameter humanizedOffererId was null or undefined when calling getOfferersCanOffererCreateEducationalOffer.'
        )
      }
      const localVarPath =
        `/offerers/{humanized_offerer_id}/eac-eligibility`.replace(
          `{${'humanized_offerer_id'}}`,
          encodeURIComponent(String(humanizedOffererId))
        )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_offerer <GET>
     * @param {string} offererId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOfferersGetOfferer(
      offererId: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'offererId' is not null or undefined
      if (offererId === null || offererId === undefined) {
        throw new RequiredError(
          'offererId',
          'Required parameter offererId was null or undefined when calling getOfferersGetOfferer.'
        )
      }
      const localVarPath = `/offerers/{offerer_id}`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(offererId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_offerers <GET>
     * @param {string} [keywords]
     * @param {number} [page]
     * @param {number} [paginate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOfferersGetOfferers(
      keywords?: string | null,
      page?: number | null,
      paginate?: number | null,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/offerers`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      if (keywords !== undefined) {
        localVarQueryParameter['keywords'] = keywords
      }
      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }
      if (paginate !== undefined) {
        localVarQueryParameter['paginate'] = paginate
      }
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary list_educational_offerers <GET>
     * @param {string} [offererId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOfferersListEducationalOfferers(
      offererId?: string | null,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/offerers/educational`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      if (offererId !== undefined) {
        localVarQueryParameter['offerer_id'] = offererId
      }
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary list_offerers_names <GET>
     * @param {boolean} [validated]
     * @param {boolean} [validatedForUser]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOfferersListOfferersNames(
      validated?: boolean | null,
      validatedForUser?: boolean | null,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/offerers/names`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      if (validated !== undefined) {
        localVarQueryParameter['validated'] = validated
      }
      if (validatedForUser !== undefined) {
        localVarQueryParameter['validated_for_user'] = validatedForUser
      }
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_categories <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOffersGetCategories(options: any = {}): Promise<FetchArgs> {
      const localVarPath = `/offers/categories`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_offer <GET>
     * @param {string} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOffersGetOffer(
      offerId: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'offerId' is not null or undefined
      if (offerId === null || offerId === undefined) {
        throw new RequiredError(
          'offerId',
          'Required parameter offerId was null or undefined when calling getOffersGetOffer.'
        )
      }
      const localVarPath = `/offers/{offer_id}`.replace(
        `{${'offer_id'}}`,
        encodeURIComponent(String(offerId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_stocks <GET>
     * @param {string} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOffersGetStocks(
      offerId: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'offerId' is not null or undefined
      if (offerId === null || offerId === undefined) {
        throw new RequiredError(
          'offerId',
          'Required parameter offerId was null or undefined when calling getOffersGetStocks.'
        )
      }
      const localVarPath = `/offers/{offer_id}/stocks`.replace(
        `{${'offer_id'}}`,
        encodeURIComponent(String(offerId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary list_offers <GET>
     * @param {string} [nameOrIsbn]
     * @param {number} [offererId]
     * @param {string} [status]
     * @param {number} [venueId]
     * @param {string} [categoryId]
     * @param {string} [creationMode]
     * @param {string} [periodBeginningDate]
     * @param {string} [periodEndingDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOffersListOffers(
      nameOrIsbn?: string | null,
      offererId?: number | null,
      status?: string | null,
      venueId?: number | null,
      categoryId?: string | null,
      creationMode?: string | null,
      periodBeginningDate?: string | null,
      periodEndingDate?: string | null,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/offers`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      if (nameOrIsbn !== undefined) {
        localVarQueryParameter['nameOrIsbn'] = nameOrIsbn
      }
      if (offererId !== undefined) {
        localVarQueryParameter['offererId'] = offererId
      }
      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }
      if (venueId !== undefined) {
        localVarQueryParameter['venueId'] = venueId
      }
      if (categoryId !== undefined) {
        localVarQueryParameter['categoryId'] = categoryId
      }
      if (creationMode !== undefined) {
        localVarQueryParameter['creationMode'] = creationMode
      }
      if (periodBeginningDate !== undefined) {
        localVarQueryParameter['periodBeginningDate'] = periodBeginningDate
      }
      if (periodEndingDate !== undefined) {
        localVarQueryParameter['periodEndingDate'] = periodEndingDate
      }
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_reimbursements_csv <GET>
     * @param {string} [venueId]
     * @param {string} [reimbursementPeriodBeginningDate]
     * @param {string} [reimbursementPeriodEndingDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReimbursementsGetReimbursementsCsv(
      venueId?: string,
      reimbursementPeriodBeginningDate?: string,
      reimbursementPeriodEndingDate?: string,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/reimbursements/csv`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      if (venueId !== undefined) {
        localVarQueryParameter['venueId'] = venueId
      }
      if (reimbursementPeriodBeginningDate !== undefined) {
        localVarQueryParameter['reimbursementPeriodBeginningDate'] =
          reimbursementPeriodBeginningDate
      }
      if (reimbursementPeriodEndingDate !== undefined) {
        localVarQueryParameter['reimbursementPeriodEndingDate'] =
          reimbursementPeriodEndingDate
      }
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_user_offerer <GET>
     * @param {string} offererId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserofferersGetUserOfferer(
      offererId: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'offererId' is not null or undefined
      if (offererId === null || offererId === undefined) {
        throw new RequiredError(
          'offererId',
          'Required parameter offererId was null or undefined when calling getUserofferersGetUserOfferer.'
        )
      }
      const localVarPath = `/userOfferers/{offerer_id}`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(offererId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary check_activation_token_exists <GET>
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersCheckActivationTokenExists(
      token: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          'token',
          'Required parameter token was null or undefined when calling getUsersCheckActivationTokenExists.'
        )
      }
      const localVarPath = `/users/token/{token}`.replace(
        `{${'token'}}`,
        encodeURIComponent(String(token))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_profile <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersGetProfile(options: any = {}): Promise<FetchArgs> {
      const localVarPath = `/users/current`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary fetch_venue_labels <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenueLabelsFetchVenueLabels(
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/venue-labels`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_venue_types <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenueTypesGetVenueTypes(options: any = {}): Promise<FetchArgs> {
      const localVarPath = `/venue-types`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary list_venue_providers <GET>
     * @param {number} venueId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenueprovidersListVenueProviders(
      venueId: number,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'venueId' is not null or undefined
      if (venueId === null || venueId === undefined) {
        throw new RequiredError(
          'venueId',
          'Required parameter venueId was null or undefined when calling getVenueprovidersListVenueProviders.'
        )
      }
      const localVarPath = `/venueProviders`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      if (venueId !== undefined) {
        localVarQueryParameter['venueId'] = venueId
      }
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_venue <GET>
     * @param {string} venueId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenuesGetVenue(
      venueId: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'venueId' is not null or undefined
      if (venueId === null || venueId === undefined) {
        throw new RequiredError(
          'venueId',
          'Required parameter venueId was null or undefined when calling getVenuesGetVenue.'
        )
      }
      const localVarPath = `/venues/{venue_id}`.replace(
        `{${'venue_id'}}`,
        encodeURIComponent(String(venueId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary get_venue_stats <GET>
     * @param {string} humanizedVenueId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenuesGetVenueStats(
      humanizedVenueId: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'humanizedVenueId' is not null or undefined
      if (humanizedVenueId === null || humanizedVenueId === undefined) {
        throw new RequiredError(
          'humanizedVenueId',
          'Required parameter humanizedVenueId was null or undefined when calling getVenuesGetVenueStats.'
        )
      }
      const localVarPath = `/venues/{humanized_venue_id}/stats`.replace(
        `{${'humanized_venue_id'}}`,
        encodeURIComponent(String(humanizedVenueId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary edit_business_unit <PATCH>
     * @param {number} businessUnitId
     * @param {BusinessUnitEditionBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchFinanceEditBusinessUnit(
      businessUnitId: number,
      body?: BusinessUnitEditionBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'businessUnitId' is not null or undefined
      if (businessUnitId === null || businessUnitId === undefined) {
        throw new RequiredError(
          'businessUnitId',
          'Required parameter businessUnitId was null or undefined when calling patchFinanceEditBusinessUnit.'
        )
      }
      const localVarPath = `/finance/business-units/{business_unit_id}`.replace(
        `{${'business_unit_id'}}`,
        encodeURIComponent(String(businessUnitId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'BusinessUnitEditionBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary cancel_educational_offer_booking <PATCH>
     * @param {string} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOffersCancelEducationalOfferBooking(
      offerId: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'offerId' is not null or undefined
      if (offerId === null || offerId === undefined) {
        throw new RequiredError(
          'offerId',
          'Required parameter offerId was null or undefined when calling patchOffersCancelEducationalOfferBooking.'
        )
      }
      const localVarPath = `/offers/{offer_id}/cancel_booking`.replace(
        `{${'offer_id'}}`,
        encodeURIComponent(String(offerId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary edit_educational_offer <PATCH>
     * @param {string} offerId
     * @param {PatchEducationalOfferBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOffersEditEducationalOffer(
      offerId: string,
      body?: PatchEducationalOfferBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'offerId' is not null or undefined
      if (offerId === null || offerId === undefined) {
        throw new RequiredError(
          'offerId',
          'Required parameter offerId was null or undefined when calling patchOffersEditEducationalOffer.'
        )
      }
      const localVarPath = `/offers/educational/{offer_id}`.replace(
        `{${'offer_id'}}`,
        encodeURIComponent(String(offerId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'PatchEducationalOfferBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary patch_all_offers_active_status <PATCH>
     * @param {PatchAllOffersActiveStatusBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOffersPatchAllOffersActiveStatus(
      body?: PatchAllOffersActiveStatusBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/offers/all-active-status`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'PatchAllOffersActiveStatusBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary patch_offer <PATCH>
     * @param {string} offerId
     * @param {PatchOfferBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOffersPatchOffer(
      offerId: string,
      body?: PatchOfferBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'offerId' is not null or undefined
      if (offerId === null || offerId === undefined) {
        throw new RequiredError(
          'offerId',
          'Required parameter offerId was null or undefined when calling patchOffersPatchOffer.'
        )
      }
      const localVarPath = `/offers/{offer_id}`.replace(
        `{${'offer_id'}}`,
        encodeURIComponent(String(offerId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'PatchOfferBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary patch_offers_active_status <PATCH>
     * @param {PatchOfferActiveStatusBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOffersPatchOffersActiveStatus(
      body?: PatchOfferActiveStatusBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/offers/active-status`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'PatchOfferActiveStatusBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary edit_educational_stock <PATCH>
     * @param {string} stockId
     * @param {EducationalStockEditionBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchStocksEditEducationalStock(
      stockId: string,
      body?: EducationalStockEditionBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'stockId' is not null or undefined
      if (stockId === null || stockId === undefined) {
        throw new RequiredError(
          'stockId',
          'Required parameter stockId was null or undefined when calling patchStocksEditEducationalStock.'
        )
      }
      const localVarPath = `/stocks/educational/{stock_id}`.replace(
        `{${'stock_id'}}`,
        encodeURIComponent(String(stockId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'EducationalStockEditionBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary patch_profile <PATCH>
     * @param {PatchProUserBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchUsersPatchProfile(
      body?: PatchProUserBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/users/current`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'PatchProUserBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary patch_user_tuto_seen <PATCH>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchUsersPatchUserTutoSeen(options: any = {}): Promise<FetchArgs> {
      const localVarPath = `/users/tuto-seen`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary validate_user <PATCH>
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchValidateValidateUser(
      token: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          'token',
          'Required parameter token was null or undefined when calling patchValidateValidateUser.'
        )
      }
      const localVarPath = `/validate/user/{token}`.replace(
        `{${'token'}}`,
        encodeURIComponent(String(token))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary edit_venue <PATCH>
     * @param {string} venueId
     * @param {EditVenueBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchVenuesEditVenue(
      venueId: string,
      body?: EditVenueBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'venueId' is not null or undefined
      if (venueId === null || venueId === undefined) {
        throw new RequiredError(
          'venueId',
          'Required parameter venueId was null or undefined when calling patchVenuesEditVenue.'
        )
      }
      const localVarPath = `/venues/{venue_id}`.replace(
        `{${'venue_id'}}`,
        encodeURIComponent(String(venueId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'EditVenueBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary create_collective_offer <POST>
     * @param {PostCollectiveOfferBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postCollectiveCreateCollectiveOffer(
      body?: PostCollectiveOfferBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/collective/offers`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'POST',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'PostCollectiveOfferBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary create_offerer <POST>
     * @param {CreateOffererQueryModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postOfferersCreateOfferer(
      body?: CreateOffererQueryModel,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/offerers`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'POST',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'CreateOffererQueryModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary generate_api_key_route <POST>
     * @param {string} offererId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postOfferersGenerateApiKeyRoute(
      offererId: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'offererId' is not null or undefined
      if (offererId === null || offererId === undefined) {
        throw new RequiredError(
          'offererId',
          'Required parameter offererId was null or undefined when calling postOfferersGenerateApiKeyRoute.'
        )
      }
      const localVarPath = `/offerers/{offerer_id}/api_keys`.replace(
        `{${'offerer_id'}}`,
        encodeURIComponent(String(offererId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'POST',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary create_educational_offer <POST>
     * @param {PostEducationalOfferBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postOffersCreateEducationalOffer(
      body?: PostEducationalOfferBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/offers/educational`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'POST',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'PostEducationalOfferBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary create_thumbnail <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postOffersCreateThumbnail(options: any = {}): Promise<FetchArgs> {
      const localVarPath = `/offers/thumbnails/`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'POST',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary post_offer <POST>
     * @param {PostOfferBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postOffersPostOffer(
      body?: PostOfferBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/offers`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'POST',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'PostOfferBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary create_educational_stock <POST>
     * @param {EducationalStockCreationBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postStocksCreateEducationalStock(
      body?: EducationalStockCreationBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/stocks/educational`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'POST',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'EducationalStockCreationBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary upsert_stocks <POST>
     * @param {StocksUpsertBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postStocksUpsertStocks(
      body?: StocksUpsertBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/stocks/bulk`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'POST',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'StocksUpsertBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary signin <POST>
     * @param {LoginUserBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUsersSignin(
      body?: LoginUserBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/users/signin`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'POST',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'LoginUserBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary create_venue_provider <POST>
     * @param {PostVenueProviderBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postVenueprovidersCreateVenueProvider(
      body?: PostVenueProviderBody,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/venueProviders`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'POST',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'PostVenueProviderBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary update_venue_provider <PUT>
     * @param {PostVenueProviderBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putVenueprovidersUpdateVenueProvider(
      body?: PostVenueProviderBody,
      options: any = {}
    ): Promise<FetchArgs> {
      const localVarPath = `/venueProviders`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PUT',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'PostVenueProviderBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (
  api: DefaultApi,
  configuration?: APIConfiguration
) {
  return {
    /**
     *
     * @summary delete_api_key <DELETE>
     * @param {string} apiKeyPrefix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOfferersDeleteApiKey(
      basePath: string,
      apiKeyPrefix: string,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).deleteOfferersDeleteApiKey(apiKeyPrefix, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary delete_stock <DELETE>
     * @param {string} stockId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteStocksDeleteStock(
      basePath: string,
      stockId: string,
      options?: any
    ): Promise<StockIdResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).deleteStocksDeleteStock(stockId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_bookings_pro <GET>
     * @param {number} [page]
     * @param {number} [venueId]
     * @param {string} [eventDate]
     * @param {BookingStatusFilter} [bookingStatusFilter]
     * @param {string} [bookingPeriodBeginningDate]
     * @param {string} [bookingPeriodEndingDate]
     * @param {OfferType} [offerType]
     * @param {string} [extra]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBookingsGetBookingsPro(
      basePath: string,
      page?: number,
      venueId?: number | null,
      eventDate?: string | null,
      bookingStatusFilter?: BookingStatusFilter,
      bookingPeriodBeginningDate?: string | null,
      bookingPeriodEndingDate?: string | null,
      offerType?: OfferType,
      extra?: string,
      options?: any
    ): Promise<ListBookingsResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getBookingsGetBookingsPro(
        page,
        venueId,
        eventDate,
        bookingStatusFilter,
        bookingPeriodBeginningDate,
        bookingPeriodEndingDate,
        offerType,
        extra,
        options
      )
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary list_collective_offers <GET>
     * @param {string} [nameOrIsbn]
     * @param {number} [offererId]
     * @param {string} [status]
     * @param {number} [venueId]
     * @param {string} [categoryId]
     * @param {string} [creationMode]
     * @param {string} [periodBeginningDate]
     * @param {string} [periodEndingDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCollectiveListCollectiveOffers(
      basePath: string,
      nameOrIsbn?: string | null,
      offererId?: number | null,
      status?: string | null,
      venueId?: number | null,
      categoryId?: string | null,
      creationMode?: string | null,
      periodBeginningDate?: string | null,
      periodEndingDate?: string | null,
      options?: any
    ): Promise<ListCollectiveOffersResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getCollectiveListCollectiveOffers(
        nameOrIsbn,
        offererId,
        status,
        venueId,
        categoryId,
        creationMode,
        periodBeginningDate,
        periodEndingDate,
        options
      )
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary list_features <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFeaturesListFeatures(
      basePath: string,
      options?: any
    ): Promise<ListFeatureResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getFeaturesListFeatures(options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_business_units <GET>
     * @param {number} [offererId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFinanceGetBusinessUnits(
      basePath: string,
      offererId?: number | null,
      options?: any
    ): Promise<BusinessUnitListResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getFinanceGetBusinessUnits(offererId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_invoices <GET>
     * @param {number} [businessUnitId]
     * @param {string} [periodBeginningDate]
     * @param {string} [periodEndingDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFinanceGetInvoices(
      basePath: string,
      businessUnitId?: number | null,
      periodBeginningDate?: string | null,
      periodEndingDate?: string | null,
      options?: any
    ): Promise<InvoiceListResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getFinanceGetInvoices(
        businessUnitId,
        periodBeginningDate,
        periodEndingDate,
        options
      )
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary can_offerer_create_educational_offer <GET>
     * @param {string} humanizedOffererId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOfferersCanOffererCreateEducationalOffer(
      basePath: string,
      humanizedOffererId: string,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getOfferersCanOffererCreateEducationalOffer(humanizedOffererId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_offerer <GET>
     * @param {string} offererId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOfferersGetOfferer(
      basePath: string,
      offererId: string,
      options?: any
    ): Promise<GetOffererResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getOfferersGetOfferer(offererId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_offerers <GET>
     * @param {string} [keywords]
     * @param {number} [page]
     * @param {number} [paginate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOfferersGetOfferers(
      basePath: string,
      keywords?: string | null,
      page?: number | null,
      paginate?: number | null,
      options?: any
    ): Promise<GetOfferersListResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getOfferersGetOfferers(keywords, page, paginate, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary list_educational_offerers <GET>
     * @param {string} [offererId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOfferersListEducationalOfferers(
      basePath: string,
      offererId?: string | null,
      options?: any
    ): Promise<GetEducationalOfferersResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getOfferersListEducationalOfferers(offererId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary list_offerers_names <GET>
     * @param {boolean} [validated]
     * @param {boolean} [validatedForUser]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOfferersListOfferersNames(
      basePath: string,
      validated?: boolean | null,
      validatedForUser?: boolean | null,
      options?: any
    ): Promise<GetOfferersNamesResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getOfferersListOfferersNames(validated, validatedForUser, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_categories <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOffersGetCategories(
      basePath: string,
      options?: any
    ): Promise<CategoriesResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getOffersGetCategories(options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_offer <GET>
     * @param {string} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOffersGetOffer(
      basePath: string,
      offerId: string,
      options?: any
    ): Promise<GetOfferResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getOffersGetOffer(offerId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_stocks <GET>
     * @param {string} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOffersGetStocks(
      basePath: string,
      offerId: string,
      options?: any
    ): Promise<StocksResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getOffersGetStocks(offerId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary list_offers <GET>
     * @param {string} [nameOrIsbn]
     * @param {number} [offererId]
     * @param {string} [status]
     * @param {number} [venueId]
     * @param {string} [categoryId]
     * @param {string} [creationMode]
     * @param {string} [periodBeginningDate]
     * @param {string} [periodEndingDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOffersListOffers(
      basePath: string,
      nameOrIsbn?: string | null,
      offererId?: number | null,
      status?: string | null,
      venueId?: number | null,
      categoryId?: string | null,
      creationMode?: string | null,
      periodBeginningDate?: string | null,
      periodEndingDate?: string | null,
      options?: any
    ): Promise<ListOffersResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getOffersListOffers(
        nameOrIsbn,
        offererId,
        status,
        venueId,
        categoryId,
        creationMode,
        periodBeginningDate,
        periodEndingDate,
        options
      )
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_reimbursements_csv <GET>
     * @param {string} [venueId]
     * @param {string} [reimbursementPeriodBeginningDate]
     * @param {string} [reimbursementPeriodEndingDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReimbursementsGetReimbursementsCsv(
      basePath: string,
      venueId?: string,
      reimbursementPeriodBeginningDate?: string,
      reimbursementPeriodEndingDate?: string,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getReimbursementsGetReimbursementsCsv(
        venueId,
        reimbursementPeriodBeginningDate,
        reimbursementPeriodEndingDate,
        options
      )
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_user_offerer <GET>
     * @param {string} offererId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserofferersGetUserOfferer(
      basePath: string,
      offererId: string,
      options?: any
    ): Promise<ListUserOfferersResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getUserofferersGetUserOfferer(offererId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary check_activation_token_exists <GET>
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersCheckActivationTokenExists(
      basePath: string,
      token: string,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getUsersCheckActivationTokenExists(token, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_profile <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersGetProfile(
      basePath: string,
      options?: any
    ): Promise<SharedCurrentUserResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getUsersGetProfile(options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary fetch_venue_labels <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenueLabelsFetchVenueLabels(
      basePath: string,
      options?: any
    ): Promise<VenueLabelListResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getVenueLabelsFetchVenueLabels(options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_venue_types <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenueTypesGetVenueTypes(
      basePath: string,
      options?: any
    ): Promise<VenueTypeListResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getVenueTypesGetVenueTypes(options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary list_venue_providers <GET>
     * @param {number} venueId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenueprovidersListVenueProviders(
      basePath: string,
      venueId: number,
      options?: any
    ): Promise<ListVenueProviderResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getVenueprovidersListVenueProviders(venueId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_venue <GET>
     * @param {string} venueId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenuesGetVenue(
      basePath: string,
      venueId: string,
      options?: any
    ): Promise<GetVenueResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getVenuesGetVenue(venueId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary get_venue_stats <GET>
     * @param {string} humanizedVenueId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVenuesGetVenueStats(
      basePath: string,
      humanizedVenueId: string,
      options?: any
    ): Promise<VenueStatsResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).getVenuesGetVenueStats(humanizedVenueId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary edit_business_unit <PATCH>
     * @param {number} businessUnitId
     * @param {BusinessUnitEditionBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchFinanceEditBusinessUnit(
      basePath: string,
      businessUnitId: number,
      body?: BusinessUnitEditionBodyModel,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).patchFinanceEditBusinessUnit(businessUnitId, body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary cancel_educational_offer_booking <PATCH>
     * @param {string} offerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOffersCancelEducationalOfferBooking(
      basePath: string,
      offerId: string,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).patchOffersCancelEducationalOfferBooking(offerId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary edit_educational_offer <PATCH>
     * @param {string} offerId
     * @param {PatchEducationalOfferBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOffersEditEducationalOffer(
      basePath: string,
      offerId: string,
      body?: PatchEducationalOfferBodyModel,
      options?: any
    ): Promise<OfferResponseIdModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).patchOffersEditEducationalOffer(offerId, body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary patch_all_offers_active_status <PATCH>
     * @param {PatchAllOffersActiveStatusBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOffersPatchAllOffersActiveStatus(
      basePath: string,
      body?: PatchAllOffersActiveStatusBodyModel,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).patchOffersPatchAllOffersActiveStatus(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary patch_offer <PATCH>
     * @param {string} offerId
     * @param {PatchOfferBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOffersPatchOffer(
      basePath: string,
      offerId: string,
      body?: PatchOfferBodyModel,
      options?: any
    ): Promise<OfferResponseIdModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).patchOffersPatchOffer(offerId, body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary patch_offers_active_status <PATCH>
     * @param {PatchOfferActiveStatusBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOffersPatchOffersActiveStatus(
      basePath: string,
      body?: PatchOfferActiveStatusBodyModel,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).patchOffersPatchOffersActiveStatus(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary edit_educational_stock <PATCH>
     * @param {string} stockId
     * @param {EducationalStockEditionBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchStocksEditEducationalStock(
      basePath: string,
      stockId: string,
      body?: EducationalStockEditionBodyModel,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).patchStocksEditEducationalStock(stockId, body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary patch_profile <PATCH>
     * @param {PatchProUserBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchUsersPatchProfile(
      basePath: string,
      body?: PatchProUserBodyModel,
      options?: any
    ): Promise<PatchProUserResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).patchUsersPatchProfile(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary patch_user_tuto_seen <PATCH>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchUsersPatchUserTutoSeen(
      basePath: string,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).patchUsersPatchUserTutoSeen(options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary validate_user <PATCH>
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchValidateValidateUser(
      basePath: string,
      token: string,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).patchValidateValidateUser(token, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary edit_venue <PATCH>
     * @param {string} venueId
     * @param {EditVenueBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchVenuesEditVenue(
      basePath: string,
      venueId: string,
      body?: EditVenueBodyModel,
      options?: any
    ): Promise<GetVenueResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).patchVenuesEditVenue(venueId, body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary create_collective_offer <POST>
     * @param {PostCollectiveOfferBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postCollectiveCreateCollectiveOffer(
      basePath: string,
      body?: PostCollectiveOfferBodyModel,
      options?: any
    ): Promise<CollectiveOfferResponseIdModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).postCollectiveCreateCollectiveOffer(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary create_offerer <POST>
     * @param {CreateOffererQueryModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postOfferersCreateOfferer(
      basePath: string,
      body?: CreateOffererQueryModel,
      options?: any
    ): Promise<GetOffererResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).postOfferersCreateOfferer(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary generate_api_key_route <POST>
     * @param {string} offererId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postOfferersGenerateApiKeyRoute(
      basePath: string,
      offererId: string,
      options?: any
    ): Promise<GenerateOffererApiKeyResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).postOfferersGenerateApiKeyRoute(offererId, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary create_educational_offer <POST>
     * @param {PostEducationalOfferBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postOffersCreateEducationalOffer(
      basePath: string,
      body?: PostEducationalOfferBodyModel,
      options?: any
    ): Promise<OfferResponseIdModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).postOffersCreateEducationalOffer(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary create_thumbnail <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postOffersCreateThumbnail(
      basePath: string,
      options?: any
    ): Promise<CreateThumbnailResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).postOffersCreateThumbnail(options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary post_offer <POST>
     * @param {PostOfferBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postOffersPostOffer(
      basePath: string,
      body?: PostOfferBodyModel,
      options?: any
    ): Promise<OfferResponseIdModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).postOffersPostOffer(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary create_educational_stock <POST>
     * @param {EducationalStockCreationBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postStocksCreateEducationalStock(
      basePath: string,
      body?: EducationalStockCreationBodyModel,
      options?: any
    ): Promise<StockIdResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).postStocksCreateEducationalStock(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary upsert_stocks <POST>
     * @param {StocksUpsertBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postStocksUpsertStocks(
      basePath: string,
      body?: StocksUpsertBodyModel,
      options?: any
    ): Promise<StockIdsResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).postStocksUpsertStocks(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary signin <POST>
     * @param {LoginUserBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUsersSignin(
      basePath: string,
      body?: LoginUserBodyModel,
      options?: any
    ): Promise<SharedLoginUserResponseModel> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).postUsersSignin(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary create_venue_provider <POST>
     * @param {PostVenueProviderBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postVenueprovidersCreateVenueProvider(
      basePath: string,
      body?: PostVenueProviderBody,
      options?: any
    ): Promise<VenueProviderResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).postVenueprovidersCreateVenueProvider(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary update_venue_provider <PUT>
     * @param {PostVenueProviderBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putVenueprovidersUpdateVenueProvider(
      basePath: string,
      body?: PostVenueProviderBody,
      options?: any
    ): Promise<VenueProviderResponse> {
      const localVarFetchArgs = await DefaultApiFetchParamCreator(
        configuration
      ).putVenueprovidersUpdateVenueProvider(body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
  }
}

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
  /**
   *
   * @summary delete_api_key <DELETE>
   * @param {string} apiKeyPrefix
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteOfferersDeleteApiKey(apiKeyPrefix: string, options?: any): Promise<{}>

  /**
   *
   * @summary delete_stock <DELETE>
   * @param {string} stockId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteStocksDeleteStock(
    stockId: string,
    options?: any
  ): Promise<StockIdResponseModel>

  /**
   *
   * @summary get_bookings_pro <GET>
   * @param {number} [page]
   * @param {number} [venueId]
   * @param {string} [eventDate]
   * @param {BookingStatusFilter} [bookingStatusFilter]
   * @param {string} [bookingPeriodBeginningDate]
   * @param {string} [bookingPeriodEndingDate]
   * @param {OfferType} [offerType]
   * @param {string} [extra]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getBookingsGetBookingsPro(
    page?: number,
    venueId?: number | null,
    eventDate?: string | null,
    bookingStatusFilter?: BookingStatusFilter,
    bookingPeriodBeginningDate?: string | null,
    bookingPeriodEndingDate?: string | null,
    offerType?: OfferType,
    extra?: string,
    options?: any
  ): Promise<ListBookingsResponseModel>

  /**
   *
   * @summary list_collective_offers <GET>
   * @param {string} [nameOrIsbn]
   * @param {number} [offererId]
   * @param {string} [status]
   * @param {number} [venueId]
   * @param {string} [categoryId]
   * @param {string} [creationMode]
   * @param {string} [periodBeginningDate]
   * @param {string} [periodEndingDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getCollectiveListCollectiveOffers(
    nameOrIsbn?: string | null,
    offererId?: number | null,
    status?: string | null,
    venueId?: number | null,
    categoryId?: string | null,
    creationMode?: string | null,
    periodBeginningDate?: string | null,
    periodEndingDate?: string | null,
    options?: any
  ): Promise<ListCollectiveOffersResponseModel>

  /**
   *
   * @summary list_features <GET>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getFeaturesListFeatures(options?: any): Promise<ListFeatureResponseModel>

  /**
   *
   * @summary get_business_units <GET>
   * @param {number} [offererId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getFinanceGetBusinessUnits(
    offererId?: number | null,
    options?: any
  ): Promise<BusinessUnitListResponseModel>

  /**
   *
   * @summary get_invoices <GET>
   * @param {number} [businessUnitId]
   * @param {string} [periodBeginningDate]
   * @param {string} [periodEndingDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getFinanceGetInvoices(
    businessUnitId?: number | null,
    periodBeginningDate?: string | null,
    periodEndingDate?: string | null,
    options?: any
  ): Promise<InvoiceListResponseModel>

  /**
   *
   * @summary can_offerer_create_educational_offer <GET>
   * @param {string} humanizedOffererId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getOfferersCanOffererCreateEducationalOffer(
    humanizedOffererId: string,
    options?: any
  ): Promise<{}>

  /**
   *
   * @summary get_offerer <GET>
   * @param {string} offererId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getOfferersGetOfferer(
    offererId: string,
    options?: any
  ): Promise<GetOffererResponseModel>

  /**
   *
   * @summary get_offerers <GET>
   * @param {string} [keywords]
   * @param {number} [page]
   * @param {number} [paginate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getOfferersGetOfferers(
    keywords?: string | null,
    page?: number | null,
    paginate?: number | null,
    options?: any
  ): Promise<GetOfferersListResponseModel>

  /**
   *
   * @summary list_educational_offerers <GET>
   * @param {string} [offererId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getOfferersListEducationalOfferers(
    offererId?: string | null,
    options?: any
  ): Promise<GetEducationalOfferersResponseModel>

  /**
   *
   * @summary list_offerers_names <GET>
   * @param {boolean} [validated]
   * @param {boolean} [validatedForUser]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getOfferersListOfferersNames(
    validated?: boolean | null,
    validatedForUser?: boolean | null,
    options?: any
  ): Promise<GetOfferersNamesResponseModel>

  /**
   *
   * @summary get_categories <GET>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getOffersGetCategories(options?: any): Promise<CategoriesResponseModel>

  /**
   *
   * @summary get_offer <GET>
   * @param {string} offerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getOffersGetOffer(
    offerId: string,
    options?: any
  ): Promise<GetOfferResponseModel>

  /**
   *
   * @summary get_stocks <GET>
   * @param {string} offerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getOffersGetStocks(
    offerId: string,
    options?: any
  ): Promise<StocksResponseModel>

  /**
   *
   * @summary list_offers <GET>
   * @param {string} [nameOrIsbn]
   * @param {number} [offererId]
   * @param {string} [status]
   * @param {number} [venueId]
   * @param {string} [categoryId]
   * @param {string} [creationMode]
   * @param {string} [periodBeginningDate]
   * @param {string} [periodEndingDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getOffersListOffers(
    nameOrIsbn?: string | null,
    offererId?: number | null,
    status?: string | null,
    venueId?: number | null,
    categoryId?: string | null,
    creationMode?: string | null,
    periodBeginningDate?: string | null,
    periodEndingDate?: string | null,
    options?: any
  ): Promise<ListOffersResponseModel>

  /**
   *
   * @summary get_reimbursements_csv <GET>
   * @param {string} [venueId]
   * @param {string} [reimbursementPeriodBeginningDate]
   * @param {string} [reimbursementPeriodEndingDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getReimbursementsGetReimbursementsCsv(
    venueId?: string,
    reimbursementPeriodBeginningDate?: string,
    reimbursementPeriodEndingDate?: string,
    options?: any
  ): Promise<{}>

  /**
   *
   * @summary get_user_offerer <GET>
   * @param {string} offererId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getUserofferersGetUserOfferer(
    offererId: string,
    options?: any
  ): Promise<ListUserOfferersResponseModel>

  /**
   *
   * @summary check_activation_token_exists <GET>
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getUsersCheckActivationTokenExists(token: string, options?: any): Promise<{}>

  /**
   *
   * @summary get_profile <GET>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getUsersGetProfile(options?: any): Promise<SharedCurrentUserResponseModel>

  /**
   *
   * @summary fetch_venue_labels <GET>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getVenueLabelsFetchVenueLabels(
    options?: any
  ): Promise<VenueLabelListResponseModel>

  /**
   *
   * @summary get_venue_types <GET>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getVenueTypesGetVenueTypes(options?: any): Promise<VenueTypeListResponseModel>

  /**
   *
   * @summary list_venue_providers <GET>
   * @param {number} venueId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getVenueprovidersListVenueProviders(
    venueId: number,
    options?: any
  ): Promise<ListVenueProviderResponse>

  /**
   *
   * @summary get_venue <GET>
   * @param {string} venueId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getVenuesGetVenue(
    venueId: string,
    options?: any
  ): Promise<GetVenueResponseModel>

  /**
   *
   * @summary get_venue_stats <GET>
   * @param {string} humanizedVenueId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getVenuesGetVenueStats(
    humanizedVenueId: string,
    options?: any
  ): Promise<VenueStatsResponseModel>

  /**
   *
   * @summary edit_business_unit <PATCH>
   * @param {number} businessUnitId
   * @param {BusinessUnitEditionBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  patchFinanceEditBusinessUnit(
    businessUnitId: number,
    body?: BusinessUnitEditionBodyModel,
    options?: any
  ): Promise<{}>

  /**
   *
   * @summary cancel_educational_offer_booking <PATCH>
   * @param {string} offerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  patchOffersCancelEducationalOfferBooking(
    offerId: string,
    options?: any
  ): Promise<{}>

  /**
   *
   * @summary edit_educational_offer <PATCH>
   * @param {string} offerId
   * @param {PatchEducationalOfferBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  patchOffersEditEducationalOffer(
    offerId: string,
    body?: PatchEducationalOfferBodyModel,
    options?: any
  ): Promise<OfferResponseIdModel>

  /**
   *
   * @summary patch_all_offers_active_status <PATCH>
   * @param {PatchAllOffersActiveStatusBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  patchOffersPatchAllOffersActiveStatus(
    body?: PatchAllOffersActiveStatusBodyModel,
    options?: any
  ): Promise<{}>

  /**
   *
   * @summary patch_offer <PATCH>
   * @param {string} offerId
   * @param {PatchOfferBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  patchOffersPatchOffer(
    offerId: string,
    body?: PatchOfferBodyModel,
    options?: any
  ): Promise<OfferResponseIdModel>

  /**
   *
   * @summary patch_offers_active_status <PATCH>
   * @param {PatchOfferActiveStatusBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  patchOffersPatchOffersActiveStatus(
    body?: PatchOfferActiveStatusBodyModel,
    options?: any
  ): Promise<{}>

  /**
   *
   * @summary edit_educational_stock <PATCH>
   * @param {string} stockId
   * @param {EducationalStockEditionBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  patchStocksEditEducationalStock(
    stockId: string,
    body?: EducationalStockEditionBodyModel,
    options?: any
  ): Promise<{}>

  /**
   *
   * @summary patch_profile <PATCH>
   * @param {PatchProUserBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  patchUsersPatchProfile(
    body?: PatchProUserBodyModel,
    options?: any
  ): Promise<PatchProUserResponseModel>

  /**
   *
   * @summary patch_user_tuto_seen <PATCH>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  patchUsersPatchUserTutoSeen(options?: any): Promise<{}>

  /**
   *
   * @summary validate_user <PATCH>
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  patchValidateValidateUser(token: string, options?: any): Promise<{}>

  /**
   *
   * @summary edit_venue <PATCH>
   * @param {string} venueId
   * @param {EditVenueBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  patchVenuesEditVenue(
    venueId: string,
    body?: EditVenueBodyModel,
    options?: any
  ): Promise<GetVenueResponseModel>

  /**
   *
   * @summary create_collective_offer <POST>
   * @param {PostCollectiveOfferBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  postCollectiveCreateCollectiveOffer(
    body?: PostCollectiveOfferBodyModel,
    options?: any
  ): Promise<CollectiveOfferResponseIdModel>

  /**
   *
   * @summary create_offerer <POST>
   * @param {CreateOffererQueryModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  postOfferersCreateOfferer(
    body?: CreateOffererQueryModel,
    options?: any
  ): Promise<GetOffererResponseModel>

  /**
   *
   * @summary generate_api_key_route <POST>
   * @param {string} offererId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  postOfferersGenerateApiKeyRoute(
    offererId: string,
    options?: any
  ): Promise<GenerateOffererApiKeyResponse>

  /**
   *
   * @summary create_educational_offer <POST>
   * @param {PostEducationalOfferBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  postOffersCreateEducationalOffer(
    body?: PostEducationalOfferBodyModel,
    options?: any
  ): Promise<OfferResponseIdModel>

  /**
   *
   * @summary create_thumbnail <POST>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  postOffersCreateThumbnail(
    options?: any
  ): Promise<CreateThumbnailResponseModel>

  /**
   *
   * @summary post_offer <POST>
   * @param {PostOfferBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  postOffersPostOffer(
    body?: PostOfferBodyModel,
    options?: any
  ): Promise<OfferResponseIdModel>

  /**
   *
   * @summary create_educational_stock <POST>
   * @param {EducationalStockCreationBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  postStocksCreateEducationalStock(
    body?: EducationalStockCreationBodyModel,
    options?: any
  ): Promise<StockIdResponseModel>

  /**
   *
   * @summary upsert_stocks <POST>
   * @param {StocksUpsertBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  postStocksUpsertStocks(
    body?: StocksUpsertBodyModel,
    options?: any
  ): Promise<StockIdsResponseModel>

  /**
   *
   * @summary signin <POST>
   * @param {LoginUserBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  postUsersSignin(
    body?: LoginUserBodyModel,
    options?: any
  ): Promise<SharedLoginUserResponseModel>

  /**
   *
   * @summary create_venue_provider <POST>
   * @param {PostVenueProviderBody} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  postVenueprovidersCreateVenueProvider(
    body?: PostVenueProviderBody,
    options?: any
  ): Promise<VenueProviderResponse>

  /**
   *
   * @summary update_venue_provider <PUT>
   * @param {PostVenueProviderBody} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  putVenueprovidersUpdateVenueProvider(
    body?: PostVenueProviderBody,
    options?: any
  ): Promise<VenueProviderResponse>
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
  /**
   *
   * @summary delete_api_key <DELETE>
   * @param {string} apiKeyPrefix
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async deleteOfferersDeleteApiKey(apiKeyPrefix: string, options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.deleteOfferersDeleteApiKey(
      this.basePath,
      apiKeyPrefix,
      options
    )
  }
  /**
   *
   * @summary delete_stock <DELETE>
   * @param {string} stockId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async deleteStocksDeleteStock(stockId: string, options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.deleteStocksDeleteStock(
      this.basePath,
      stockId,
      options
    )
  }
  /**
   *
   * @summary get_bookings_pro <GET>
   * @param {number} [page]
   * @param {number} [venueId]
   * @param {string} [eventDate]
   * @param {BookingStatusFilter} [bookingStatusFilter]
   * @param {string} [bookingPeriodBeginningDate]
   * @param {string} [bookingPeriodEndingDate]
   * @param {OfferType} [offerType]
   * @param {string} [extra]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getBookingsGetBookingsPro(
    page?: number,
    venueId?: number | null,
    eventDate?: string | null,
    bookingStatusFilter?: BookingStatusFilter,
    bookingPeriodBeginningDate?: string | null,
    bookingPeriodEndingDate?: string | null,
    offerType?: OfferType,
    extra?: string,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getBookingsGetBookingsPro(
      this.basePath,
      page,
      venueId,
      eventDate,
      bookingStatusFilter,
      bookingPeriodBeginningDate,
      bookingPeriodEndingDate,
      offerType,
      extra,
      options
    )
  }
  /**
   *
   * @summary list_collective_offers <GET>
   * @param {string} [nameOrIsbn]
   * @param {number} [offererId]
   * @param {string} [status]
   * @param {number} [venueId]
   * @param {string} [categoryId]
   * @param {string} [creationMode]
   * @param {string} [periodBeginningDate]
   * @param {string} [periodEndingDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getCollectiveListCollectiveOffers(
    nameOrIsbn?: string | null,
    offererId?: number | null,
    status?: string | null,
    venueId?: number | null,
    categoryId?: string | null,
    creationMode?: string | null,
    periodBeginningDate?: string | null,
    periodEndingDate?: string | null,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getCollectiveListCollectiveOffers(
      this.basePath,
      nameOrIsbn,
      offererId,
      status,
      venueId,
      categoryId,
      creationMode,
      periodBeginningDate,
      periodEndingDate,
      options
    )
  }
  /**
   *
   * @summary list_features <GET>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getFeaturesListFeatures(options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getFeaturesListFeatures(this.basePath, options)
  }
  /**
   *
   * @summary get_business_units <GET>
   * @param {number} [offererId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getFinanceGetBusinessUnits(
    offererId?: number | null,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getFinanceGetBusinessUnits(
      this.basePath,
      offererId,
      options
    )
  }
  /**
   *
   * @summary get_invoices <GET>
   * @param {number} [businessUnitId]
   * @param {string} [periodBeginningDate]
   * @param {string} [periodEndingDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getFinanceGetInvoices(
    businessUnitId?: number | null,
    periodBeginningDate?: string | null,
    periodEndingDate?: string | null,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getFinanceGetInvoices(
      this.basePath,
      businessUnitId,
      periodBeginningDate,
      periodEndingDate,
      options
    )
  }
  /**
   *
   * @summary can_offerer_create_educational_offer <GET>
   * @param {string} humanizedOffererId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getOfferersCanOffererCreateEducationalOffer(
    humanizedOffererId: string,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getOfferersCanOffererCreateEducationalOffer(
      this.basePath,
      humanizedOffererId,
      options
    )
  }
  /**
   *
   * @summary get_offerer <GET>
   * @param {string} offererId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getOfferersGetOfferer(offererId: string, options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getOfferersGetOfferer(
      this.basePath,
      offererId,
      options
    )
  }
  /**
   *
   * @summary get_offerers <GET>
   * @param {string} [keywords]
   * @param {number} [page]
   * @param {number} [paginate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getOfferersGetOfferers(
    keywords?: string | null,
    page?: number | null,
    paginate?: number | null,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getOfferersGetOfferers(
      this.basePath,
      keywords,
      page,
      paginate,
      options
    )
  }
  /**
   *
   * @summary list_educational_offerers <GET>
   * @param {string} [offererId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getOfferersListEducationalOfferers(
    offererId?: string | null,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getOfferersListEducationalOfferers(
      this.basePath,
      offererId,
      options
    )
  }
  /**
   *
   * @summary list_offerers_names <GET>
   * @param {boolean} [validated]
   * @param {boolean} [validatedForUser]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getOfferersListOfferersNames(
    validated?: boolean | null,
    validatedForUser?: boolean | null,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getOfferersListOfferersNames(
      this.basePath,
      validated,
      validatedForUser,
      options
    )
  }
  /**
   *
   * @summary get_categories <GET>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getOffersGetCategories(options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getOffersGetCategories(this.basePath, options)
  }
  /**
   *
   * @summary get_offer <GET>
   * @param {string} offerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getOffersGetOffer(offerId: string, options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getOffersGetOffer(this.basePath, offerId, options)
  }
  /**
   *
   * @summary get_stocks <GET>
   * @param {string} offerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getOffersGetStocks(offerId: string, options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getOffersGetStocks(this.basePath, offerId, options)
  }
  /**
   *
   * @summary list_offers <GET>
   * @param {string} [nameOrIsbn]
   * @param {number} [offererId]
   * @param {string} [status]
   * @param {number} [venueId]
   * @param {string} [categoryId]
   * @param {string} [creationMode]
   * @param {string} [periodBeginningDate]
   * @param {string} [periodEndingDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getOffersListOffers(
    nameOrIsbn?: string | null,
    offererId?: number | null,
    status?: string | null,
    venueId?: number | null,
    categoryId?: string | null,
    creationMode?: string | null,
    periodBeginningDate?: string | null,
    periodEndingDate?: string | null,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getOffersListOffers(
      this.basePath,
      nameOrIsbn,
      offererId,
      status,
      venueId,
      categoryId,
      creationMode,
      periodBeginningDate,
      periodEndingDate,
      options
    )
  }
  /**
   *
   * @summary get_reimbursements_csv <GET>
   * @param {string} [venueId]
   * @param {string} [reimbursementPeriodBeginningDate]
   * @param {string} [reimbursementPeriodEndingDate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getReimbursementsGetReimbursementsCsv(
    venueId?: string,
    reimbursementPeriodBeginningDate?: string,
    reimbursementPeriodEndingDate?: string,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getReimbursementsGetReimbursementsCsv(
      this.basePath,
      venueId,
      reimbursementPeriodBeginningDate,
      reimbursementPeriodEndingDate,
      options
    )
  }
  /**
   *
   * @summary get_user_offerer <GET>
   * @param {string} offererId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getUserofferersGetUserOfferer(offererId: string, options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getUserofferersGetUserOfferer(
      this.basePath,
      offererId,
      options
    )
  }
  /**
   *
   * @summary check_activation_token_exists <GET>
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getUsersCheckActivationTokenExists(
    token: string,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getUsersCheckActivationTokenExists(
      this.basePath,
      token,
      options
    )
  }
  /**
   *
   * @summary get_profile <GET>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getUsersGetProfile(options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getUsersGetProfile(this.basePath, options)
  }
  /**
   *
   * @summary fetch_venue_labels <GET>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getVenueLabelsFetchVenueLabels(options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getVenueLabelsFetchVenueLabels(this.basePath, options)
  }
  /**
   *
   * @summary get_venue_types <GET>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getVenueTypesGetVenueTypes(options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getVenueTypesGetVenueTypes(this.basePath, options)
  }
  /**
   *
   * @summary list_venue_providers <GET>
   * @param {number} venueId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getVenueprovidersListVenueProviders(
    venueId: number,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getVenueprovidersListVenueProviders(
      this.basePath,
      venueId,
      options
    )
  }
  /**
   *
   * @summary get_venue <GET>
   * @param {string} venueId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getVenuesGetVenue(venueId: string, options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getVenuesGetVenue(this.basePath, venueId, options)
  }
  /**
   *
   * @summary get_venue_stats <GET>
   * @param {string} humanizedVenueId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async getVenuesGetVenueStats(humanizedVenueId: string, options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.getVenuesGetVenueStats(
      this.basePath,
      humanizedVenueId,
      options
    )
  }
  /**
   *
   * @summary edit_business_unit <PATCH>
   * @param {number} businessUnitId
   * @param {BusinessUnitEditionBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async patchFinanceEditBusinessUnit(
    businessUnitId: number,
    body?: BusinessUnitEditionBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.patchFinanceEditBusinessUnit(
      this.basePath,
      businessUnitId,
      body,
      options
    )
  }
  /**
   *
   * @summary cancel_educational_offer_booking <PATCH>
   * @param {string} offerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async patchOffersCancelEducationalOfferBooking(
    offerId: string,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.patchOffersCancelEducationalOfferBooking(
      this.basePath,
      offerId,
      options
    )
  }
  /**
   *
   * @summary edit_educational_offer <PATCH>
   * @param {string} offerId
   * @param {PatchEducationalOfferBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async patchOffersEditEducationalOffer(
    offerId: string,
    body?: PatchEducationalOfferBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.patchOffersEditEducationalOffer(
      this.basePath,
      offerId,
      body,
      options
    )
  }
  /**
   *
   * @summary patch_all_offers_active_status <PATCH>
   * @param {PatchAllOffersActiveStatusBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async patchOffersPatchAllOffersActiveStatus(
    body?: PatchAllOffersActiveStatusBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.patchOffersPatchAllOffersActiveStatus(
      this.basePath,
      body,
      options
    )
  }
  /**
   *
   * @summary patch_offer <PATCH>
   * @param {string} offerId
   * @param {PatchOfferBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async patchOffersPatchOffer(
    offerId: string,
    body?: PatchOfferBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.patchOffersPatchOffer(
      this.basePath,
      offerId,
      body,
      options
    )
  }
  /**
   *
   * @summary patch_offers_active_status <PATCH>
   * @param {PatchOfferActiveStatusBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async patchOffersPatchOffersActiveStatus(
    body?: PatchOfferActiveStatusBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.patchOffersPatchOffersActiveStatus(
      this.basePath,
      body,
      options
    )
  }
  /**
   *
   * @summary edit_educational_stock <PATCH>
   * @param {string} stockId
   * @param {EducationalStockEditionBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async patchStocksEditEducationalStock(
    stockId: string,
    body?: EducationalStockEditionBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.patchStocksEditEducationalStock(
      this.basePath,
      stockId,
      body,
      options
    )
  }
  /**
   *
   * @summary patch_profile <PATCH>
   * @param {PatchProUserBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async patchUsersPatchProfile(
    body?: PatchProUserBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.patchUsersPatchProfile(this.basePath, body, options)
  }
  /**
   *
   * @summary patch_user_tuto_seen <PATCH>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async patchUsersPatchUserTutoSeen(options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.patchUsersPatchUserTutoSeen(this.basePath, options)
  }
  /**
   *
   * @summary validate_user <PATCH>
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async patchValidateValidateUser(token: string, options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.patchValidateValidateUser(
      this.basePath,
      token,
      options
    )
  }
  /**
   *
   * @summary edit_venue <PATCH>
   * @param {string} venueId
   * @param {EditVenueBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async patchVenuesEditVenue(
    venueId: string,
    body?: EditVenueBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.patchVenuesEditVenue(
      this.basePath,
      venueId,
      body,
      options
    )
  }
  /**
   *
   * @summary create_collective_offer <POST>
   * @param {PostCollectiveOfferBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async postCollectiveCreateCollectiveOffer(
    body?: PostCollectiveOfferBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.postCollectiveCreateCollectiveOffer(
      this.basePath,
      body,
      options
    )
  }
  /**
   *
   * @summary create_offerer <POST>
   * @param {CreateOffererQueryModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async postOfferersCreateOfferer(
    body?: CreateOffererQueryModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.postOfferersCreateOfferer(this.basePath, body, options)
  }
  /**
   *
   * @summary generate_api_key_route <POST>
   * @param {string} offererId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async postOfferersGenerateApiKeyRoute(
    offererId: string,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.postOfferersGenerateApiKeyRoute(
      this.basePath,
      offererId,
      options
    )
  }
  /**
   *
   * @summary create_educational_offer <POST>
   * @param {PostEducationalOfferBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async postOffersCreateEducationalOffer(
    body?: PostEducationalOfferBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.postOffersCreateEducationalOffer(
      this.basePath,
      body,
      options
    )
  }
  /**
   *
   * @summary create_thumbnail <POST>
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async postOffersCreateThumbnail(options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.postOffersCreateThumbnail(this.basePath, options)
  }
  /**
   *
   * @summary post_offer <POST>
   * @param {PostOfferBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async postOffersPostOffer(body?: PostOfferBodyModel, options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.postOffersPostOffer(this.basePath, body, options)
  }
  /**
   *
   * @summary create_educational_stock <POST>
   * @param {EducationalStockCreationBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async postStocksCreateEducationalStock(
    body?: EducationalStockCreationBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.postStocksCreateEducationalStock(
      this.basePath,
      body,
      options
    )
  }
  /**
   *
   * @summary upsert_stocks <POST>
   * @param {StocksUpsertBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async postStocksUpsertStocks(
    body?: StocksUpsertBodyModel,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.postStocksUpsertStocks(this.basePath, body, options)
  }
  /**
   *
   * @summary signin <POST>
   * @param {LoginUserBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async postUsersSignin(body?: LoginUserBodyModel, options?: any) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.postUsersSignin(this.basePath, body, options)
  }
  /**
   *
   * @summary create_venue_provider <POST>
   * @param {PostVenueProviderBody} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async postVenueprovidersCreateVenueProvider(
    body?: PostVenueProviderBody,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.postVenueprovidersCreateVenueProvider(
      this.basePath,
      body,
      options
    )
  }
  /**
   *
   * @summary update_venue_provider <PUT>
   * @param {PostVenueProviderBody} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public async putVenueprovidersUpdateVenueProvider(
    body?: PostVenueProviderBody,
    options?: any
  ) {
    const functionalApi = DefaultApiFp(this, this.configuration)
    return functionalApi.putVenueprovidersUpdateVenueProvider(
      this.basePath,
      body,
      options
    )
  }
}
