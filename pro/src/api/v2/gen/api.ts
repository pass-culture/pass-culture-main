/// <reference path="./custom.d.ts" />
// tslint:disable
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * pass Culture pro public API v2
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */
import url from "url";

// TODO: ModelObject should be removed when offer.extraData is correctly typed on api
import { EmptyResponse, ModelObject, handleGeneratedApiResponse, safeFetch } from "api/helpers";

import { APIConfiguration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    protected configuration?: APIConfiguration;
    constructor(configuration?: APIConfiguration, protected basePath: string = BASE_PATH) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}


export enum BookingFormula {
    PLACE = 'PLACE',
    ABO = 'ABO',
    Empty = ''
}
export enum BookingOfferType {
    BIEN = 'BIEN',
    EVENEMENT = 'EVENEMENT'
}
export interface GetBookingResponse {
    bookingId: string;
    dateOfBirth: string;
    datetime: string;
    ean13?: string | null;
    email: string;
    formula: BookingFormula;
    isUsed: boolean;
    offerId: number;
    offerName: string;
    offerType: BookingOfferType;
    phoneNumber: string;
    price: number;
    publicOfferId: string;
    quantity: number;
    theater: any;
    userName: string;
    venueAddress?: string | null;
    venueDepartmentCode?: string | null;
    venueName: string;
}

export interface UpdateVenueStockBodyModel {
    available: number;
    price?: number | null;
    ref: string;
}

export interface UpdateVenueStocksBodyModel {
    stocks: Array<UpdateVenueStockBodyModel>;
}

export interface ValidationError extends Array<ValidationErrorElement> {
}

export interface ValidationErrorElement {
    ctx?: any;
    loc: Array<string>;
    msg: string;
    type: string;
}

/**
 * APIContremarqueApi - fetch parameter creator
 * @export
 */
export const APIContremarqueApiFetchParamCreator = function (configuration?: APIConfiguration) {
    return {
        /**
         * Le code “contremarque” ou \"token\" est une chaîne de caractères permettant d’identifier la réservation et qui sert de preuve de réservation. Ce code unique est généré pour chaque réservation d'un utilisateur sur l'application et lui est transmis à cette occasion.
         * @summary Consultation d'une réservation.
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookingsGetBookingByTokenV2(token: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getBookingsGetBookingByTokenV2.');
            }
            const localVarPath = `/v2/bookings/token/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Annulation de la validation d'une réservation.
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBookingsPatchBookingKeepByToken(token: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling patchBookingsPatchBookingKeepByToken.');
            }
            const localVarPath = `/v2/bookings/keep/token/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pour confirmer que la réservation a bien été utilisée par le jeune.
         * @summary Validation d'une réservation.
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBookingsPatchBookingUseByToken(token: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling patchBookingsPatchBookingUseByToken.');
            }
            const localVarPath = `/v2/bookings/use/token/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bien que, dans le cas d’un événement, l’utilisateur ne peut plus annuler sa réservation 72h avant le début de ce dernier, cette API permet d’annuler la réservation d’un utilisateur si elle n’a pas encore été validé.
         * @summary Annulation d'une réservation.
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBookingsPatchCancelBookingByToken(token: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling patchBookingsPatchCancelBookingByToken.');
            }
            const localVarPath = `/v2/bookings/cancel/token/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIContremarqueApi - functional programming interface
 * @export
 */
export const APIContremarqueApiFp = function(api: APIContremarqueApi, configuration?: APIConfiguration) {
    return {
        /**
         * Le code “contremarque” ou \"token\" est une chaîne de caractères permettant d’identifier la réservation et qui sert de preuve de réservation. Ce code unique est généré pour chaque réservation d'un utilisateur sur l'application et lui est transmis à cette occasion.
         * @summary Consultation d'une réservation.
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookingsGetBookingByTokenV2(basePath: string, token: string, options?: any): Promise<GetBookingResponse> {
            const localVarFetchArgs = await APIContremarqueApiFetchParamCreator(configuration).getBookingsGetBookingByTokenV2(token, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary Annulation de la validation d'une réservation.
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBookingsPatchBookingKeepByToken(basePath: string, token: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await APIContremarqueApiFetchParamCreator(configuration).patchBookingsPatchBookingKeepByToken(token, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * Pour confirmer que la réservation a bien été utilisée par le jeune.
         * @summary Validation d'une réservation.
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBookingsPatchBookingUseByToken(basePath: string, token: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await APIContremarqueApiFetchParamCreator(configuration).patchBookingsPatchBookingUseByToken(token, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * Bien que, dans le cas d’un événement, l’utilisateur ne peut plus annuler sa réservation 72h avant le début de ce dernier, cette API permet d’annuler la réservation d’un utilisateur si elle n’a pas encore été validé.
         * @summary Annulation d'une réservation.
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBookingsPatchCancelBookingByToken(basePath: string, token: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await APIContremarqueApiFetchParamCreator(configuration).patchBookingsPatchCancelBookingByToken(token, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
    }
};

/**
 * APIContremarqueApi - interface
 * @export
 * @interface APIContremarqueApi
 */
export interface APIContremarqueApiInterface {
    /**
     * Le code “contremarque” ou \"token\" est une chaîne de caractères permettant d’identifier la réservation et qui sert de preuve de réservation. Ce code unique est généré pour chaque réservation d'un utilisateur sur l'application et lui est transmis à cette occasion.
     * @summary Consultation d'une réservation.
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIContremarqueApiInterface
     */
    getBookingsGetBookingByTokenV2(token: string, options?: any): Promise<GetBookingResponse>;

    /**
     * 
     * @summary Annulation de la validation d'une réservation.
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIContremarqueApiInterface
     */
    patchBookingsPatchBookingKeepByToken(token: string, options?: any): Promise<{}>;

    /**
     * Pour confirmer que la réservation a bien été utilisée par le jeune.
     * @summary Validation d'une réservation.
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIContremarqueApiInterface
     */
    patchBookingsPatchBookingUseByToken(token: string, options?: any): Promise<{}>;

    /**
     * Bien que, dans le cas d’un événement, l’utilisateur ne peut plus annuler sa réservation 72h avant le début de ce dernier, cette API permet d’annuler la réservation d’un utilisateur si elle n’a pas encore été validé.
     * @summary Annulation d'une réservation.
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIContremarqueApiInterface
     */
    patchBookingsPatchCancelBookingByToken(token: string, options?: any): Promise<{}>;

}

/**
 * APIContremarqueApi - object-oriented interface
 * @export
 * @class APIContremarqueApi
 * @extends {BaseAPI}
 */
export class APIContremarqueApi extends BaseAPI implements APIContremarqueApiInterface {
    /**
     * Le code “contremarque” ou \"token\" est une chaîne de caractères permettant d’identifier la réservation et qui sert de preuve de réservation. Ce code unique est généré pour chaque réservation d'un utilisateur sur l'application et lui est transmis à cette occasion.
     * @summary Consultation d'une réservation.
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIContremarqueApi
     */
    public async getBookingsGetBookingByTokenV2(token: string, options?: any) {
        const functionalApi = APIContremarqueApiFp(this, this.configuration)
        return functionalApi.getBookingsGetBookingByTokenV2(this.basePath, token, options)
    }
    /**
     * 
     * @summary Annulation de la validation d'une réservation.
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIContremarqueApi
     */
    public async patchBookingsPatchBookingKeepByToken(token: string, options?: any) {
        const functionalApi = APIContremarqueApiFp(this, this.configuration)
        return functionalApi.patchBookingsPatchBookingKeepByToken(this.basePath, token, options)
    }
    /**
     * Pour confirmer que la réservation a bien été utilisée par le jeune.
     * @summary Validation d'une réservation.
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIContremarqueApi
     */
    public async patchBookingsPatchBookingUseByToken(token: string, options?: any) {
        const functionalApi = APIContremarqueApiFp(this, this.configuration)
        return functionalApi.patchBookingsPatchBookingUseByToken(this.basePath, token, options)
    }
    /**
     * Bien que, dans le cas d’un événement, l’utilisateur ne peut plus annuler sa réservation 72h avant le début de ce dernier, cette API permet d’annuler la réservation d’un utilisateur si elle n’a pas encore été validé.
     * @summary Annulation d'une réservation.
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIContremarqueApi
     */
    public async patchBookingsPatchCancelBookingByToken(token: string, options?: any) {
        const functionalApi = APIContremarqueApiFp(this, this.configuration)
        return functionalApi.patchBookingsPatchCancelBookingByToken(this.basePath, token, options)
    }
}

/**
 * APIStocksApi - fetch parameter creator
 * @export
 */
export const APIStocksApiFetchParamCreator = function (configuration?: APIConfiguration) {
    return {
        /**
         * Seuls les livres, préalablement présents dans le catalogue du pass Culture seront pris en compte, tous les autres stocks seront filtrés. Les stocks sont référencés par leur isbn au format EAN13. Le champ \"available\" représente la quantité de stocks disponible en librairie. Le champ \"price\" (optionnel) correspond au prix en euros. Le paramètre {venue_id} correspond à un lieu qui doit être attaché à la structure à laquelle la clé d'API utilisée est reliée.
         * @summary Mise à jour des stocks d'un lieu enregistré auprès du pass Culture.
         * @param {number} venueId 
         * @param {UpdateVenueStocksBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVenueUpdateStocks(venueId: number, body?: UpdateVenueStocksBodyModel, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'venueId' is not null or undefined
            if (venueId === null || venueId === undefined) {
                throw new RequiredError('venueId','Required parameter venueId was null or undefined when calling postVenueUpdateStocks.');
            }
            const localVarPath = `/v2/venue/{venue_id}/stocks`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateVenueStocksBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIStocksApi - functional programming interface
 * @export
 */
export const APIStocksApiFp = function(api: APIStocksApi, configuration?: APIConfiguration) {
    return {
        /**
         * Seuls les livres, préalablement présents dans le catalogue du pass Culture seront pris en compte, tous les autres stocks seront filtrés. Les stocks sont référencés par leur isbn au format EAN13. Le champ \"available\" représente la quantité de stocks disponible en librairie. Le champ \"price\" (optionnel) correspond au prix en euros. Le paramètre {venue_id} correspond à un lieu qui doit être attaché à la structure à laquelle la clé d'API utilisée est reliée.
         * @summary Mise à jour des stocks d'un lieu enregistré auprès du pass Culture.
         * @param {number} venueId 
         * @param {UpdateVenueStocksBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVenueUpdateStocks(basePath: string, venueId: number, body?: UpdateVenueStocksBodyModel, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await APIStocksApiFetchParamCreator(configuration).postVenueUpdateStocks(venueId, body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
    }
};

/**
 * APIStocksApi - interface
 * @export
 * @interface APIStocksApi
 */
export interface APIStocksApiInterface {
    /**
     * Seuls les livres, préalablement présents dans le catalogue du pass Culture seront pris en compte, tous les autres stocks seront filtrés. Les stocks sont référencés par leur isbn au format EAN13. Le champ \"available\" représente la quantité de stocks disponible en librairie. Le champ \"price\" (optionnel) correspond au prix en euros. Le paramètre {venue_id} correspond à un lieu qui doit être attaché à la structure à laquelle la clé d'API utilisée est reliée.
     * @summary Mise à jour des stocks d'un lieu enregistré auprès du pass Culture.
     * @param {number} venueId 
     * @param {UpdateVenueStocksBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIStocksApiInterface
     */
    postVenueUpdateStocks(venueId: number, body?: UpdateVenueStocksBodyModel, options?: any): Promise<{}>;

}

/**
 * APIStocksApi - object-oriented interface
 * @export
 * @class APIStocksApi
 * @extends {BaseAPI}
 */
export class APIStocksApi extends BaseAPI implements APIStocksApiInterface {
    /**
     * Seuls les livres, préalablement présents dans le catalogue du pass Culture seront pris en compte, tous les autres stocks seront filtrés. Les stocks sont référencés par leur isbn au format EAN13. Le champ \"available\" représente la quantité de stocks disponible en librairie. Le champ \"price\" (optionnel) correspond au prix en euros. Le paramètre {venue_id} correspond à un lieu qui doit être attaché à la structure à laquelle la clé d'API utilisée est reliée.
     * @summary Mise à jour des stocks d'un lieu enregistré auprès du pass Culture.
     * @param {number} venueId 
     * @param {UpdateVenueStocksBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIStocksApi
     */
    public async postVenueUpdateStocks(venueId: number, body?: UpdateVenueStocksBodyModel, options?: any) {
        const functionalApi = APIStocksApiFp(this, this.configuration)
        return functionalApi.postVenueUpdateStocks(this.basePath, venueId, body, options)
    }
}
