/// <reference path="./custom.d.ts" />
// tslint:disable
/* eslint-disable */
/**
 * pass Culture pro public API v2
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */
import url from 'url'

// TODO: ModelObject should be removed when offer.extraData is correctly typed on api
import {
  EmptyResponse,
  ModelObject,
  handleGeneratedApiResponse,
  safeFetch,
} from 'api/helpers'

import { APIConfiguration } from './configuration'

const BASE_PATH = '/'.replace(/\/+$/, '')

export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
}

export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

export interface FetchArgs {
  url: string
  options: any
}

export class BaseAPI {
  protected configuration?: APIConfiguration
  constructor(
    configuration?: APIConfiguration,
    protected basePath: string = BASE_PATH
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    }
  }
}

export class RequiredError extends Error {
  name = 'RequiredError'
  constructor(public field: string, msg?: string) {
    super(msg)
  }
}

export enum BookingFormula {
  PLACE = 'PLACE',
  ABO = 'ABO',
  Empty = '',
}
export enum BookingOfferType {
  BIEN = 'BIEN',
  EVENEMENT = 'EVENEMENT',
}
export interface GetBookingResponse {
  bookingId: string
  dateOfBirth: string
  datetime: string
  ean13?: string | null
  email: string
  formula: BookingFormula
  isUsed: boolean
  offerId: number
  offerName: string
  offerType: BookingOfferType
  phoneNumber: string
  price: number
  publicOfferId: string
  quantity: number
  theater: any
  userName: string
  venueAddress?: string | null
  venueDepartmentCode?: string | null
  venueName: string
}

export interface UpdateVenueStockBodyModel {
  available: number
  price?: number | null
  ref: string
}

export interface UpdateVenueStocksBodyModel {
  stocks: Array<UpdateVenueStockBodyModel>
}

export interface ValidationError extends Array<ValidationErrorElement> {}

export interface ValidationErrorElement {
  ctx?: any
  loc: Array<string>
  msg: string
  type: string
}

/**
 * APIContremarqueApi - fetch parameter creator
 * @export
 */
export const APIContremarqueApiFetchParamCreator = function (
  configuration?: APIConfiguration
) {
  return {
    /**
     * Le code “contremarque” ou \"token\" est une chaîne de caractères permettant d’identifier la réservation et qui sert de preuve de réservation. Ce code unique est généré pour chaque réservation d'un utilisateur sur l'application et lui est transmis à cette occasion.
     * @summary Consultation d'une réservation.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBookingsGetBookingByTokenV2(
      token: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          'token',
          'Required parameter token was null or undefined when calling getBookingsGetBookingByTokenV2.'
        )
      }
      const localVarPath = `/v2/bookings/token/{token}`.replace(
        `{${'token'}}`,
        encodeURIComponent(String(token))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'GET',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Annulation de la validation d'une réservation.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchBookingsPatchBookingKeepByToken(
      token: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          'token',
          'Required parameter token was null or undefined when calling patchBookingsPatchBookingKeepByToken.'
        )
      }
      const localVarPath = `/v2/bookings/keep/token/{token}`.replace(
        `{${'token'}}`,
        encodeURIComponent(String(token))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Pour confirmer que la réservation a bien été utilisée par le jeune.
     * @summary Validation d'une réservation.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchBookingsPatchBookingUseByToken(
      token: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          'token',
          'Required parameter token was null or undefined when calling patchBookingsPatchBookingUseByToken.'
        )
      }
      const localVarPath = `/v2/bookings/use/token/{token}`.replace(
        `{${'token'}}`,
        encodeURIComponent(String(token))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Bien que, dans le cas d’un évènement, l’utilisateur ne peut plus annuler sa réservation 72h avant le début de ce dernier, cette API permet d’annuler la réservation d’un utilisateur si elle n’a pas encore été validé.
     * @summary Annulation d'une réservation.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchBookingsPatchCancelBookingByToken(
      token: string,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          'token',
          'Required parameter token was null or undefined when calling patchBookingsPatchCancelBookingByToken.'
        )
      }
      const localVarPath = `/v2/bookings/cancel/token/{token}`.replace(
        `{${'token'}}`,
        encodeURIComponent(String(token))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'PATCH',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * APIContremarqueApi - functional programming interface
 * @export
 */
export const APIContremarqueApiFp = function (
  api: APIContremarqueApi,
  configuration?: APIConfiguration
) {
  return {
    /**
     * Le code “contremarque” ou \"token\" est une chaîne de caractères permettant d’identifier la réservation et qui sert de preuve de réservation. Ce code unique est généré pour chaque réservation d'un utilisateur sur l'application et lui est transmis à cette occasion.
     * @summary Consultation d'une réservation.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBookingsGetBookingByTokenV2(
      basePath: string,
      token: string,
      options?: any
    ): Promise<GetBookingResponse> {
      const localVarFetchArgs = await APIContremarqueApiFetchParamCreator(
        configuration
      ).getBookingsGetBookingByTokenV2(token, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     *
     * @summary Annulation de la validation d'une réservation.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchBookingsPatchBookingKeepByToken(
      basePath: string,
      token: string,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await APIContremarqueApiFetchParamCreator(
        configuration
      ).patchBookingsPatchBookingKeepByToken(token, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     * Pour confirmer que la réservation a bien été utilisée par le jeune.
     * @summary Validation d'une réservation.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchBookingsPatchBookingUseByToken(
      basePath: string,
      token: string,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await APIContremarqueApiFetchParamCreator(
        configuration
      ).patchBookingsPatchBookingUseByToken(token, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
    /**
     * Bien que, dans le cas d’un évènement, l’utilisateur ne peut plus annuler sa réservation 72h avant le début de ce dernier, cette API permet d’annuler la réservation d’un utilisateur si elle n’a pas encore été validé.
     * @summary Annulation d'une réservation.
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchBookingsPatchCancelBookingByToken(
      basePath: string,
      token: string,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await APIContremarqueApiFetchParamCreator(
        configuration
      ).patchBookingsPatchCancelBookingByToken(token, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
  }
}

/**
 * APIContremarqueApi - interface
 * @export
 * @interface APIContremarqueApi
 */
export interface APIContremarqueApiInterface {
  /**
   * Le code “contremarque” ou \"token\" est une chaîne de caractères permettant d’identifier la réservation et qui sert de preuve de réservation. Ce code unique est généré pour chaque réservation d'un utilisateur sur l'application et lui est transmis à cette occasion.
   * @summary Consultation d'une réservation.
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIContremarqueApiInterface
   */
  getBookingsGetBookingByTokenV2(
    token: string,
    options?: any
  ): Promise<GetBookingResponse>

  /**
   *
   * @summary Annulation de la validation d'une réservation.
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIContremarqueApiInterface
   */
  patchBookingsPatchBookingKeepByToken(
    token: string,
    options?: any
  ): Promise<{}>

  /**
   * Pour confirmer que la réservation a bien été utilisée par le jeune.
   * @summary Validation d'une réservation.
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIContremarqueApiInterface
   */
  patchBookingsPatchBookingUseByToken(token: string, options?: any): Promise<{}>

  /**
   * Bien que, dans le cas d’un évènement, l’utilisateur ne peut plus annuler sa réservation 72h avant le début de ce dernier, cette API permet d’annuler la réservation d’un utilisateur si elle n’a pas encore été validé.
   * @summary Annulation d'une réservation.
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIContremarqueApiInterface
   */
  patchBookingsPatchCancelBookingByToken(
    token: string,
    options?: any
  ): Promise<{}>
}

/**
 * APIContremarqueApi - object-oriented interface
 * @export
 * @class APIContremarqueApi
 * @extends {BaseAPI}
 */
export class APIContremarqueApi
  extends BaseAPI
  implements APIContremarqueApiInterface
{
  /**
   * Le code “contremarque” ou \"token\" est une chaîne de caractères permettant d’identifier la réservation et qui sert de preuve de réservation. Ce code unique est généré pour chaque réservation d'un utilisateur sur l'application et lui est transmis à cette occasion.
   * @summary Consultation d'une réservation.
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIContremarqueApi
   */
  public async getBookingsGetBookingByTokenV2(token: string, options?: any) {
    const functionalApi = APIContremarqueApiFp(this, this.configuration)
    return functionalApi.getBookingsGetBookingByTokenV2(
      this.basePath,
      token,
      options
    )
  }
  /**
   *
   * @summary Annulation de la validation d'une réservation.
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIContremarqueApi
   */
  public async patchBookingsPatchBookingKeepByToken(
    token: string,
    options?: any
  ) {
    const functionalApi = APIContremarqueApiFp(this, this.configuration)
    return functionalApi.patchBookingsPatchBookingKeepByToken(
      this.basePath,
      token,
      options
    )
  }
  /**
   * Pour confirmer que la réservation a bien été utilisée par le jeune.
   * @summary Validation d'une réservation.
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIContremarqueApi
   */
  public async patchBookingsPatchBookingUseByToken(
    token: string,
    options?: any
  ) {
    const functionalApi = APIContremarqueApiFp(this, this.configuration)
    return functionalApi.patchBookingsPatchBookingUseByToken(
      this.basePath,
      token,
      options
    )
  }
  /**
   * Bien que, dans le cas d’un évènement, l’utilisateur ne peut plus annuler sa réservation 72h avant le début de ce dernier, cette API permet d’annuler la réservation d’un utilisateur si elle n’a pas encore été validé.
   * @summary Annulation d'une réservation.
   * @param {string} token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIContremarqueApi
   */
  public async patchBookingsPatchCancelBookingByToken(
    token: string,
    options?: any
  ) {
    const functionalApi = APIContremarqueApiFp(this, this.configuration)
    return functionalApi.patchBookingsPatchCancelBookingByToken(
      this.basePath,
      token,
      options
    )
  }
}

/**
 * APIStocksApi - fetch parameter creator
 * @export
 */
export const APIStocksApiFetchParamCreator = function (
  configuration?: APIConfiguration
) {
  return {
    /**
     * Seuls les livres, préalablement présents dans le catalogue du pass Culture seront pris en compte, tous les autres stocks seront filtrés. Les stocks sont référencés par leur isbn au format EAN13. Le champ \"available\" représente la quantité de stocks disponible en librairie. Le champ \"price\" (optionnel) correspond au prix en euros. Le paramètre {venue_id} correspond à un lieu qui doit être attaché à la structure à laquelle la clé d'API utilisée est reliée.
     * @summary Mise à jour des stocks d'un lieu enregistré auprès du pass Culture.
     * @param {number} venueId
     * @param {UpdateVenueStocksBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postVenueUpdateStocks(
      venueId: number,
      body?: UpdateVenueStocksBodyModel,
      options: any = {}
    ): Promise<FetchArgs> {
      // verify required parameter 'venueId' is not null or undefined
      if (venueId === null || venueId === undefined) {
        throw new RequiredError(
          'venueId',
          'Required parameter venueId was null or undefined when calling postVenueUpdateStocks.'
        )
      }
      const localVarPath = `/v2/venue/{venue_id}/stocks`.replace(
        `{${'venue_id'}}`,
        encodeURIComponent(String(venueId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        {
          method: 'POST',
          credentials: 'includes',
        },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'UpdateVenueStocksBodyModel' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''
      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * APIStocksApi - functional programming interface
 * @export
 */
export const APIStocksApiFp = function (
  api: APIStocksApi,
  configuration?: APIConfiguration
) {
  return {
    /**
     * Seuls les livres, préalablement présents dans le catalogue du pass Culture seront pris en compte, tous les autres stocks seront filtrés. Les stocks sont référencés par leur isbn au format EAN13. Le champ \"available\" représente la quantité de stocks disponible en librairie. Le champ \"price\" (optionnel) correspond au prix en euros. Le paramètre {venue_id} correspond à un lieu qui doit être attaché à la structure à laquelle la clé d'API utilisée est reliée.
     * @summary Mise à jour des stocks d'un lieu enregistré auprès du pass Culture.
     * @param {number} venueId
     * @param {UpdateVenueStocksBodyModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postVenueUpdateStocks(
      basePath: string,
      venueId: number,
      body?: UpdateVenueStocksBodyModel,
      options?: any
    ): Promise<EmptyResponse> {
      const localVarFetchArgs = await APIStocksApiFetchParamCreator(
        configuration
      ).postVenueUpdateStocks(venueId, body, options)
      const response = await safeFetch(
        basePath + localVarFetchArgs.url,
        localVarFetchArgs.options
      )
      return handleGeneratedApiResponse(response)
    },
  }
}

/**
 * APIStocksApi - interface
 * @export
 * @interface APIStocksApi
 */
export interface APIStocksApiInterface {
  /**
   * Seuls les livres, préalablement présents dans le catalogue du pass Culture seront pris en compte, tous les autres stocks seront filtrés. Les stocks sont référencés par leur isbn au format EAN13. Le champ \"available\" représente la quantité de stocks disponible en librairie. Le champ \"price\" (optionnel) correspond au prix en euros. Le paramètre {venue_id} correspond à un lieu qui doit être attaché à la structure à laquelle la clé d'API utilisée est reliée.
   * @summary Mise à jour des stocks d'un lieu enregistré auprès du pass Culture.
   * @param {number} venueId
   * @param {UpdateVenueStocksBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIStocksApiInterface
   */
  postVenueUpdateStocks(
    venueId: number,
    body?: UpdateVenueStocksBodyModel,
    options?: any
  ): Promise<{}>
}

/**
 * APIStocksApi - object-oriented interface
 * @export
 * @class APIStocksApi
 * @extends {BaseAPI}
 */
export class APIStocksApi extends BaseAPI implements APIStocksApiInterface {
  /**
   * Seuls les livres, préalablement présents dans le catalogue du pass Culture seront pris en compte, tous les autres stocks seront filtrés. Les stocks sont référencés par leur isbn au format EAN13. Le champ \"available\" représente la quantité de stocks disponible en librairie. Le champ \"price\" (optionnel) correspond au prix en euros. Le paramètre {venue_id} correspond à un lieu qui doit être attaché à la structure à laquelle la clé d'API utilisée est reliée.
   * @summary Mise à jour des stocks d'un lieu enregistré auprès du pass Culture.
   * @param {number} venueId
   * @param {UpdateVenueStocksBodyModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIStocksApi
   */
  public async postVenueUpdateStocks(
    venueId: number,
    body?: UpdateVenueStocksBodyModel,
    options?: any
  ) {
    const functionalApi = APIStocksApiFp(this, this.configuration)
    return functionalApi.postVenueUpdateStocks(
      this.basePath,
      venueId,
      body,
      options
    )
  }
}
