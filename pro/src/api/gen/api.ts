/// <reference path="./custom.d.ts" />
// tslint:disable
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Service API Document
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */
import url from "url";

// TODO: ModelObject should be removed when offer.extraData is correctly typed on api
import { EmptyResponse, ModelObject, handleGeneratedApiResponse, safeFetch } from "api/helpers";

import { APIConfiguration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    protected configuration?: APIConfiguration;
    constructor(configuration?: APIConfiguration, protected basePath: string = BASE_PATH) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}


export interface BannerMetaModel {
    imageCredit?: string | null;
}

export enum BookingStatusFilter {
    Booked = 'booked',
    Validated = 'validated',
    Reimbursed = 'reimbursed'
}
export interface BusinessUnitEditionBodyModel {
    siret: string;
}

export interface BusinessUnitListQueryModel {
    offererId?: number | null;
}

export interface BusinessUnitListResponseModel extends Array<BusinessUnitResponseModel> {
}

export interface BusinessUnitResponseModel {
    bic?: string | null;
    iban?: string | null;
    id: number;
    name: string;
    siret?: string | null;
}

export interface CategoriesResponseModel {
    categories: Array<CategoryResponseModel>;
    subcategories: Array<SubcategoryResponseModel>;
}

export interface CategoryResponseModel {
    id: string;
    isSelectable: boolean;
    proLabel: string;
}

export interface ChangePasswordBodyModel {
    newConfirmationPassword: string;
    newPassword: string;
    oldPassword: string;
}

export interface Configuration {
    id: number;
    name: string;
}

export interface CreateOffererQueryModel {
    address?: string | null;
    city: string;
    latitude?: number | null;
    longitude?: number | null;
    name: string;
    postalCode: string;
    siren: string;
}

export interface CreateThumbnailResponseModel {
    id: string;
}

export interface DeleteBatchUserAttributesRequest {
    userId: number;
}

export interface EditVenueBodyModel {
    address?: string | null;
    audioDisabilityCompliant?: boolean | null;
    bookingEmail?: string | null;
    businessUnitId?: number | null;
    city?: string | null;
    comment?: string | null;
    contact?: VenueContactModel | null;
    description?: string | null;
    isAccessibilityAppliedOnAllOffers?: boolean | null;
    isEmailAppliedOnAllOffers?: boolean | null;
    isWithdrawalAppliedOnAllOffers?: boolean | null;
    latitude?: number | string | null;
    longitude?: number | string | null;
    mentalDisabilityCompliant?: boolean | null;
    motorDisabilityCompliant?: boolean | null;
    name?: string | null;
    postalCode?: string | null;
    publicName?: string | null;
    siret?: string | null;
    venueLabelId?: number | null;
    venueTypeCode?: string | null;
    visualDisabilityCompliant?: boolean | null;
    withdrawalDetails?: string | null;
}

export interface EducationalOfferExtraDataOfferVenueBodyModel {
    addressType: OfferAddressType;
    otherAddress: string;
    venueId: string;
}

export interface EducationalOfferPartialExtraDataBodyModel {
    contactEmail?: string | null;
    contactPhone?: string | null;
    offerVenue?: EducationalOfferExtraDataOfferVenueBodyModel | null;
    students?: Array<string> | null;
}

export interface EducationalOfferShadowStockBodyModel {
    educationalPriceDetail?: string | null;
}

export interface EducationalStockCreationBodyModel {
    beginningDatetime: Date;
    bookingLimitDatetime?: Date | null;
    educationalPriceDetail?: string | null;
    numberOfTickets: number;
    offerId: number;
    totalPrice: number;
}

export interface EducationalStockEditionBodyModel {
    beginningDatetime?: Date | null;
    bookingLimitDatetime?: Date | null;
    educationalPriceDetail?: string | null;
    numberOfTickets?: number | null;
    totalPrice?: number | null;
}

export interface GenerateOffererApiKeyResponse {
    apiKey: string;
}

export interface GetEducationalOffererResponseModel {
    id: string;
    managedVenues: Array<GetEducationalOffererVenueResponseModel>;
    name: string;
}

export interface GetEducationalOffererVenueResponseModel {
    address?: string | null;
    audioDisabilityCompliant?: boolean | null;
    city?: string | null;
    id: string;
    isVirtual: boolean;
    mentalDisabilityCompliant?: boolean | null;
    motorDisabilityCompliant?: boolean | null;
    name: string;
    postalCode?: string | null;
    publicName?: string | null;
    visualDisabilityCompliant?: boolean | null;
}

export interface GetEducationalOfferersQueryModel {
    offererId?: string | null;
}

export interface GetEducationalOfferersResponseModel {
    educationalOfferers: Array<GetEducationalOffererResponseModel>;
}

export interface GetOfferLastProviderResponseModel {
    enabledForPro: boolean;
    id: string;
    isActive: boolean;
    localClass?: string | null;
    name: string;
}

export interface GetOfferManagingOffererResponseModel {
    address?: string | null;
    city: string;
    dateCreated: Date;
    dateModifiedAtLastProvider?: Date | null;
    fieldsUpdated: Array<string>;
    id: string;
    idAtProviders?: string | null;
    isActive: boolean;
    isValidated: boolean;
    lastProviderId?: string | null;
    name: string;
    postalCode: string;
    siren?: string | null;
    thumbCount: number;
}

export interface GetOfferMediationResponseModel {
    authorId?: string | null;
    credit?: string | null;
    dateCreated: Date;
    dateModifiedAtLastProvider?: Date | null;
    fieldsUpdated: Array<string>;
    id: string;
    idAtProviders?: string | null;
    isActive: boolean;
    lastProviderId?: string | null;
    offerId: string;
    thumbCount: number;
    thumbUrl?: string | null;
}

export interface GetOfferProductResponseModel {
    ageMax?: number | null;
    ageMin?: number | null;
    conditions?: string | null;
    dateModifiedAtLastProvider?: Date | null;
    description?: string | null;
    durationMinutes?: number | null;
    extraData?: ModelObject | null;
    fieldsUpdated: Array<string>;
    id: string;
    idAtProviders?: string | null;
    isGcuCompatible: boolean;
    isNational: boolean;
    lastProviderId?: string | null;
    mediaUrls: Array<string>;
    name: string;
    owningOffererId?: string | null;
    thumbCount: number;
    url?: string | null;
}

export interface GetOfferResponseModel {
    activeMediation?: GetOfferMediationResponseModel | null;
    ageMax?: number | null;
    ageMin?: number | null;
    audioDisabilityCompliant?: boolean | null;
    bookingEmail?: string | null;
    conditions?: string | null;
    dateCreated: Date;
    dateModifiedAtLastProvider?: Date | null;
    dateRange: Array<Date>;
    description?: string | null;
    durationMinutes?: number | null;
    externalTicketOfficeUrl?: string | null;
    extraData?: ModelObject | null;
    fieldsUpdated: Array<string>;
    hasBookingLimitDatetimesPassed: boolean;
    id: string;
    isActive: boolean;
    isBookable: boolean;
    isDigital: boolean;
    isDuo: boolean;
    isEditable: boolean;
    isEducational: boolean;
    isEvent: boolean;
    isNational: boolean;
    isThing: boolean;
    lastProvider?: GetOfferLastProviderResponseModel | null;
    lastProviderId?: string | null;
    mediaUrls: Array<string>;
    mediations: Array<GetOfferMediationResponseModel>;
    mentalDisabilityCompliant?: boolean | null;
    motorDisabilityCompliant?: boolean | null;
    name: string;
    nonHumanizedId: number;
    product: GetOfferProductResponseModel;
    productId: string;
    status: OfferStatus;
    stocks: Array<GetOfferStockResponseModel>;
    subcategoryId: SubcategoryIdEnum;
    thumbUrl?: string | null;
    url?: string | null;
    venue: GetOfferVenueResponseModel;
    venueId: string;
    visualDisabilityCompliant?: boolean | null;
    withdrawalDetails?: string | null;
}

export interface GetOfferStockResponseModel {
    beginningDatetime?: Date | null;
    bookingLimitDatetime?: Date | null;
    bookingsQuantity: number;
    cancellationLimitDate?: Date | null;
    dateCreated: Date;
    dateModified: Date;
    dateModifiedAtLastProvider?: Date | null;
    fieldsUpdated: Array<string>;
    hasActivationCode: boolean;
    id: string;
    idAtProviders?: string | null;
    isBookable: boolean;
    isEventDeletable: boolean;
    isEventExpired: boolean;
    isSoftDeleted: boolean;
    lastProviderId?: string | null;
    offerId: string;
    price: number;
    quantity?: number | null;
    remainingQuantity?: number | string | null;
}

export interface GetOfferVenueResponseModel {
    address?: string | null;
    audioDisabilityCompliant?: boolean | null;
    bookingEmail?: string | null;
    city?: string | null;
    comment?: string | null;
    dateCreated?: Date | null;
    dateModifiedAtLastProvider?: Date | null;
    departementCode?: string | null;
    fieldsUpdated: Array<string>;
    id: string;
    idAtProviders?: string | null;
    isValidated: boolean;
    isVirtual: boolean;
    lastProviderId?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    managingOfferer: GetOfferManagingOffererResponseModel;
    managingOffererId: string;
    mentalDisabilityCompliant?: boolean | null;
    motorDisabilityCompliant?: boolean | null;
    name: string;
    postalCode?: string | null;
    publicName?: string | null;
    siret?: string | null;
    thumbCount: number;
    venueLabelId?: string | null;
    visualDisabilityCompliant?: boolean | null;
}

export interface GetOffererListQueryModel {
    keywords?: string | null;
    page?: number | null;
    paginate?: number | null;
}

export interface GetOffererNameResponseModel {
    id: string;
    name: string;
}

export interface GetOffererResponseModel {
    address?: string | null;
    apiKey: OffererApiKey;
    bic?: string | null;
    city: string;
    dateCreated: Date;
    dateModifiedAtLastProvider?: Date | null;
    demarchesSimplifieesApplicationId?: string | null;
    fieldsUpdated: Array<string>;
    hasDigitalVenueAtLeastOneOffer: boolean;
    hasMissingBankInformation: boolean;
    iban?: string | null;
    id: string;
    idAtProviders?: string | null;
    isActive: boolean;
    isValidated: boolean;
    lastProviderId?: string | null;
    managedVenues: Array<GetOffererVenueResponseModel>;
    name: string;
    postalCode: string;
    siren?: string | null;
}

export interface GetOffererVenueResponseModel {
    address?: string | null;
    audioDisabilityCompliant?: boolean | null;
    bookingEmail?: string | null;
    businessUnitId?: number | null;
    city?: string | null;
    comment?: string | null;
    departementCode?: string | null;
    id: string;
    isValidated: boolean;
    isVirtual: boolean;
    managingOffererId: string;
    mentalDisabilityCompliant?: boolean | null;
    motorDisabilityCompliant?: boolean | null;
    name: string;
    postalCode?: string | null;
    publicName?: string | null;
    venueLabelId?: string | null;
    visualDisabilityCompliant?: boolean | null;
    withdrawalDetails?: string | null;
}

export interface GetOfferersListResponseModel extends Array<GetOfferersResponseModel> {
}

export interface GetOfferersNamesQueryModel {
    validated?: boolean | null;
    validatedForUser?: boolean | null;
}

export interface GetOfferersNamesResponseModel {
    offerersNames: Array<GetOffererNameResponseModel>;
}

export interface GetOfferersResponseModel {
    address?: string | null;
    bic?: string | null;
    city: string;
    dateCreated: Date;
    dateModifiedAtLastProvider?: Date | null;
    dateValidated?: Date | null;
    demarchesSimplifieesApplicationId?: string | null;
    fieldsUpdated: Array<string>;
    iban?: string | null;
    id: string;
    idAtProviders?: string | null;
    isActive: boolean;
    isValidated: boolean;
    lastProviderId?: string | null;
    managedVenues: Array<GetOffererVenueResponseModel>;
    nOffers: number;
    name: string;
    postalCode: string;
    siren?: string | null;
    thumbCount: number;
    userHasAccess: boolean;
}

export interface GetVenueListResponseModel {
    venues: Array<VenueListItemResponseModel>;
}

export interface GetVenueManagingOffererResponseModel {
    address?: string | null;
    bic?: string | null;
    city: string;
    dateCreated: Date;
    dateModifiedAtLastProvider?: Date | null;
    demarchesSimplifieesApplicationId?: string | null;
    fieldsUpdated: Array<string>;
    iban?: string | null;
    id: string;
    idAtProviders?: string | null;
    isValidated: boolean;
    lastProviderId?: string | null;
    name: string;
    postalCode: string;
    siren?: string | null;
}

export interface GetVenueResponseModel {
    address?: string | null;
    audioDisabilityCompliant?: boolean | null;
    bannerMeta?: BannerMetaModel | null;
    bannerUrl?: string | null;
    bic?: string | null;
    bookingEmail?: string | null;
    businessUnit?: BusinessUnitResponseModel | null;
    businessUnitId?: number | null;
    city?: string | null;
    comment?: string | null;
    contact?: VenueContactModel | null;
    dateCreated: Date;
    dateModifiedAtLastProvider?: Date | null;
    demarchesSimplifieesApplicationId?: string | null;
    departementCode?: string | null;
    description?: string | null;
    fieldsUpdated: Array<string>;
    iban?: string | null;
    id: string;
    idAtProviders?: string | null;
    isBusinessUnitMainVenue?: boolean | null;
    isPermanent?: boolean | null;
    isValidated: boolean;
    isVirtual: boolean;
    lastProviderId?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    managingOfferer: GetVenueManagingOffererResponseModel;
    managingOffererId: string;
    mentalDisabilityCompliant?: boolean | null;
    motorDisabilityCompliant?: boolean | null;
    name: string;
    nonHumanizedId: number;
    postalCode?: string | null;
    publicName?: string | null;
    siret?: string | null;
    venueLabelId?: string | null;
    venueTypeCode?: VenueTypeCode | null;
    visualDisabilityCompliant?: boolean | null;
    withdrawalDetails?: string | null;
}

export interface InvoiceListQueryModel {
    businessUnitId?: number | null;
    periodBeginningDate?: string | null;
    periodEndingDate?: string | null;
}

export interface InvoiceListResponseModel extends Array<InvoiceResponseModel> {
}

export interface InvoiceResponseModel {
    amount: number;
    businessUnitName: string;
    date: string;
    reference: string;
    url: string;
}

export interface LegacyBookingResponse {
    bookingId?: string | null;
    date?: string | null;
    email?: string | null;
    isUsed?: boolean | null;
    offerName?: string | null;
    userName?: string | null;
    venueDepartementCode?: string | null;
}

export interface ListBookingsQueryModel {
    bookingPeriodBeginningDate: string;
    bookingPeriodEndingDate: string;
    bookingStatusFilter: BookingStatusFilter;
    eventDate?: Date | null;
    extra?: string;
    offerType?: OfferType | null;
    page?: number;
    venueId?: number | null;
}

export interface ListBookingsResponseModel {
    bookingsRecap: Array<any>;
    page: number;
    pages: number;
    total: number;
}

export interface ListOffersOfferResponseModel {
    hasBookingLimitDatetimesPassed: boolean;
    id: string;
    isActive: boolean;
    isEditable: boolean;
    isEducational: boolean;
    isEvent: boolean;
    isShowcase?: boolean | null;
    isThing: boolean;
    name: string;
    productIsbn?: string | null;
    status: string;
    stocks: Array<ListOffersStockResponseModel>;
    subcategoryId: SubcategoryIdEnum;
    thumbUrl?: string | null;
    venue: ListOffersVenueResponseModel;
    venueId: string;
}

export interface ListOffersQueryModel {
    categoryId?: string | null;
    creationMode?: string | null;
    nameOrIsbn?: string | null;
    offererId?: number | null;
    periodBeginningDate?: string | null;
    periodEndingDate?: string | null;
    status?: string | null;
    venueId?: number | null;
}

export interface ListOffersResponseModel extends Array<ListOffersOfferResponseModel> {
}

export interface ListOffersStockResponseModel {
    beginningDatetime?: Date | null;
    hasBookingLimitDatetimePassed: boolean;
    id: string;
    offerId: string;
    remainingQuantity: number | string;
}

export interface ListOffersVenueResponseModel {
    departementCode?: string | null;
    id: string;
    isVirtual: boolean;
    managingOffererId: string;
    name: string;
    offererName: string;
    publicName?: string | null;
}

export interface ListUserOfferersResponseModel extends Array<UserOffererResponseModel> {
}

export interface ListVenueProviderQuery {
    venueId: number;
}

export interface ListVenueProviderResponse {
    venueProviders: Array<VenueProviderResponse>;
}

export interface LoginUserBodyModel {
    identifier: string;
    password: string;
}

export interface NewPasswordBodyModel {
    newPassword: string;
    token: string;
}

export enum OfferAddressType {
    OffererVenue = 'offererVenue',
    School = 'school',
    Other = 'other'
}
export interface OfferResponseIdModel {
    id: string;
}

export enum OfferStatus {
    ACTIVE = 'ACTIVE',
    PENDING = 'PENDING',
    EXPIRED = 'EXPIRED',
    REJECTED = 'REJECTED',
    SOLDOUT = 'SOLD_OUT',
    INACTIVE = 'INACTIVE',
    DRAFT = 'DRAFT'
}
export interface OfferType {
}

export interface OfferType1 {
}

export interface OffererApiKey {
    maxAllowed: number;
    prefixes: Array<string>;
}

export interface PatchAllOffersActiveStatusBodyModel {
    categoryId?: string | null;
    creationMode?: string | null;
    isActive: boolean;
    nameOrIsbn?: string | null;
    offererId?: number | null;
    periodBeginningDate?: Date | null;
    periodEndingDate?: Date | null;
    status?: string | null;
    venueId?: number | null;
}

export interface PatchBookingByTokenQueryModel {
    email?: string | null;
    offerId?: string | null;
}

export interface PatchEducationalOfferBodyModel {
    audioDisabilityCompliant?: boolean | null;
    bookingEmail?: string | null;
    description?: string | null;
    durationMinutes?: number | null;
    extraData?: EducationalOfferPartialExtraDataBodyModel | null;
    mentalDisabilityCompliant?: boolean | null;
    motorDisabilityCompliant?: boolean | null;
    name?: string | null;
    subcategoryId?: SubcategoryIdEnum | null;
    visualDisabilityCompliant?: boolean | null;
}

export interface PatchOfferActiveStatusBodyModel {
    ids: Array<number>;
    isActive: boolean;
}

export interface PatchOfferBodyModel {
    ageMax?: number | null;
    ageMin?: number | null;
    audioDisabilityCompliant?: boolean | null;
    bookingEmail?: string | null;
    conditions?: string | null;
    description?: string | null;
    durationMinutes?: number | null;
    externalTicketOfficeUrl?: string | null;
    extraData?: ModelObject | null;
    isActive?: boolean | null;
    isDuo?: boolean | null;
    isNational?: boolean | null;
    mediaUrls?: Array<string> | null;
    mentalDisabilityCompliant?: boolean | null;
    motorDisabilityCompliant?: boolean | null;
    name?: string | null;
    productId?: string | null;
    url?: string | null;
    venueId?: string | null;
    visualDisabilityCompliant?: boolean | null;
    withdrawalDetails?: string | null;
}

export interface PatchProUserBodyModel {
    email?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    phoneNumber?: string | null;
}

export interface PatchProUserResponseModel {
    email: string;
    firstName?: string | null;
    lastName?: string | null;
    phoneNumber?: string | null;
}

export enum PhoneValidationStatusType {
    BlockedTooManyCodeSendings = 'blocked-too-many-code-sendings',
    BlockedTooManyCodeVerificationTries = 'blocked-too-many-code-verification-tries',
    Validated = 'validated'
}
export interface PostEducationalOfferBodyModel {
    audioDisabilityCompliant?: boolean;
    bookingEmail?: string | null;
    description?: string | null;
    durationMinutes?: number | null;
    extraData: PostEducationalOfferExtraDataBodyModel;
    mentalDisabilityCompliant?: boolean;
    motorDisabilityCompliant?: boolean;
    name: string;
    offererId: string;
    subcategoryId: string;
    venueId: string;
    visualDisabilityCompliant?: boolean;
}

export interface PostEducationalOfferExtraDataBodyModel {
    contactEmail: string;
    contactPhone: string;
    offerVenue: EducationalOfferExtraDataOfferVenueBodyModel;
    students: Array<string>;
}

export interface PostOfferBodyModel {
    ageMax?: number | null;
    ageMin?: number | null;
    audioDisabilityCompliant?: boolean;
    bookingEmail?: string | null;
    conditions?: string | null;
    description?: string | null;
    durationMinutes?: number | null;
    externalTicketOfficeUrl?: string | null;
    extraData?: ModelObject | null;
    isDuo?: boolean | null;
    isEducational?: boolean | null;
    isNational?: boolean | null;
    mediaUrls?: Array<string> | null;
    mentalDisabilityCompliant?: boolean;
    motorDisabilityCompliant?: boolean;
    name?: string | null;
    offererId?: string | null;
    productId?: string | null;
    subcategoryId?: string | null;
    url?: string | null;
    venueId: string;
    visualDisabilityCompliant?: boolean;
    withdrawalDetails?: string | null;
}

export interface PostVenueBodyModel {
    address: string;
    audioDisabilityCompliant?: boolean | null;
    bookingEmail: string;
    businessUnitId?: number | null;
    city: string;
    comment?: string | null;
    contact?: VenueContactModel | null;
    description?: string | null;
    latitude: number;
    longitude: number;
    managingOffererId: string;
    mentalDisabilityCompliant?: boolean | null;
    motorDisabilityCompliant?: boolean | null;
    name: string;
    postalCode: string;
    publicName?: string | null;
    siret?: string | null;
    venueLabelId?: string | null;
    venueTypeCode: string;
    visualDisabilityCompliant?: boolean | null;
    withdrawalDetails?: string | null;
}

export interface PostVenueProviderBody {
    isDuo?: boolean;
    price?: string;
    providerId: string;
    quantity?: number;
    venueId: string;
    venueIdAtOfferProvider?: string;
}

export interface ProUserCreationBodyModel {
    address?: string | null;
    city?: string | null;
    contactOk?: boolean | null;
    email: string;
    firstName?: string | null;
    lastName?: string | null;
    latitude?: number | null;
    longitude?: number | null;
    name?: string | null;
    password: string;
    phoneNumber: string;
    postalCode?: string | null;
    publicName?: string | null;
    siren?: string | null;
}

export interface ProviderResponse {
    enabledForPro: boolean;
    id: string;
    isActive: boolean;
    localClass?: string;
    name: string;
}

export interface ReimbursementCsvQueryModel {
    reimbursementPeriodBeginningDate?: string;
    reimbursementPeriodEndingDate?: string;
    venueId?: string;
}

export interface ResetPasswordBodyModel {
    email: string;
    token: string;
}

export interface Select2Query {
    q: string;
}

export interface Select2Response {
    items: Array<Select2ResponseItem>;
}

export interface Select2ResponseItem {
    id: number;
    text: string;
}

export interface SendTransactionalEmailRequest {
    attachment?: any | null;
    htmlContent?: string | null;
    params?: any | null;
    recipients: Array<string>;
    replyTo?: any | null;
    sender: any;
    subject?: string | null;
    tags?: Array<string> | null;
    templateId?: number | null;
}

export interface SharedCurrentUserResponseModel {
    activity?: string | null;
    address?: string | null;
    city?: string | null;
    civility?: string | null;
    dateCreated: Date;
    dateOfBirth?: Date | null;
    departementCode?: string | null;
    email: string;
    externalIds?: any | null;
    firstName?: string | null;
    hasPhysicalVenues?: boolean | null;
    hasSeenProTutorials?: boolean | null;
    id: string;
    idPieceNumber?: string | null;
    isAdmin: boolean;
    isEmailValidated: boolean;
    lastConnectionDate?: Date | null;
    lastName?: string | null;
    needsToFillCulturalSurvey?: boolean | null;
    notificationSubscriptions?: any | null;
    phoneNumber?: string | null;
    phoneValidationStatus?: PhoneValidationStatusType | null;
    postalCode?: string | null;
    publicName?: string | null;
    roles: Array<UserRole>;
}

export interface SharedLoginUserResponseModel {
    activity?: string | null;
    address?: string | null;
    city?: string | null;
    civility?: string | null;
    dateCreated: Date;
    dateOfBirth?: Date | null;
    departementCode?: string | null;
    email: string;
    firstName?: string | null;
    hasPhysicalVenues?: boolean | null;
    hasSeenProTutorials?: boolean | null;
    id: string;
    isAdmin: boolean;
    isEmailValidated: boolean;
    lastConnectionDate?: Date | null;
    lastName?: string | null;
    needsToFillCulturalSurvey?: boolean | null;
    phoneNumber?: string | null;
    postalCode?: string | null;
    publicName?: string | null;
    roles: Array<UserRole>;
}

export interface StockCreationBodyModel {
    activationCodes?: Array<string> | null;
    activationCodesExpirationDatetime?: Date | null;
    beginningDatetime?: Date | null;
    bookingLimitDatetime?: Date | null;
    price: number;
    quantity?: number | null;
}

export interface StockEditionBodyModel {
    beginningDatetime?: Date | null;
    bookingLimitDatetime?: Date | null;
    id: number;
    price: number;
    quantity?: number | null;
}

export interface StockEditionResponseModel {
    beginningDatetime: Date;
    bookingLimitDatetime: Date;
    educationalPriceDetail?: string | null;
    id: string;
    isEducationalStockEditable: boolean;
    numberOfTickets?: number | null;
    price: number;
}

export interface StockIdResponseModel {
    id: string;
}

export interface StockIdsResponseModel {
    stockIds: Array<StockIdResponseModel>;
}

export interface StockResponseModel {
    activationCodesExpirationDatetime?: Date | null;
    beginningDatetime?: Date | null;
    bookingLimitDatetime?: Date | null;
    bookingsQuantity: number;
    dateCreated: Date;
    dateModified: Date;
    educationalPriceDetail?: string | null;
    hasActivationCodes: boolean;
    id: string;
    isEducationalStockEditable?: boolean | null;
    isEventDeletable: boolean;
    isEventExpired: boolean;
    numberOfTickets?: number | null;
    offerId: string;
    price: number;
    quantity?: number | null;
}

export interface StocksResponseModel {
    stocks: Array<StockResponseModel>;
}

export interface StocksUpsertBodyModel {
    offerId: number;
    stocks: Array<StockCreationBodyModel | StockEditionBodyModel>;
}

export enum SubcategoryIdEnum {
    ABOBIBLIOTHEQUE = 'ABO_BIBLIOTHEQUE',
    ABOCONCERT = 'ABO_CONCERT',
    ABOJEUVIDEO = 'ABO_JEU_VIDEO',
    ABOLIVRENUMERIQUE = 'ABO_LIVRE_NUMERIQUE',
    ABOLUDOTHEQUE = 'ABO_LUDOTHEQUE',
    ABOMEDIATHEQUE = 'ABO_MEDIATHEQUE',
    ABOMUSEE = 'ABO_MUSEE',
    ABOPLATEFORMEMUSIQUE = 'ABO_PLATEFORME_MUSIQUE',
    ABOPLATEFORMEVIDEO = 'ABO_PLATEFORME_VIDEO',
    ABOPRATIQUEART = 'ABO_PRATIQUE_ART',
    ABOPRESSEENLIGNE = 'ABO_PRESSE_EN_LIGNE',
    ABOSPECTACLE = 'ABO_SPECTACLE',
    ACHATINSTRUMENT = 'ACHAT_INSTRUMENT',
    ACTIVATIONEVENT = 'ACTIVATION_EVENT',
    ACTIVATIONTHING = 'ACTIVATION_THING',
    APPCULTURELLE = 'APP_CULTURELLE',
    ATELIERPRATIQUEART = 'ATELIER_PRATIQUE_ART',
    AUTRESUPPORTNUMERIQUE = 'AUTRE_SUPPORT_NUMERIQUE',
    BONACHATINSTRUMENT = 'BON_ACHAT_INSTRUMENT',
    CAPTATIONMUSIQUE = 'CAPTATION_MUSIQUE',
    CARTECINEILLIMITE = 'CARTE_CINE_ILLIMITE',
    CARTECINEMULTISEANCES = 'CARTE_CINE_MULTISEANCES',
    CARTEJEUNES = 'CARTE_JEUNES',
    CARTEMUSEE = 'CARTE_MUSEE',
    CINEPLEINAIR = 'CINE_PLEIN_AIR',
    CINEVENTEDISTANCE = 'CINE_VENTE_DISTANCE',
    CONCERT = 'CONCERT',
    CONCOURS = 'CONCOURS',
    CONFERENCE = 'CONFERENCE',
    DECOUVERTEMETIERS = 'DECOUVERTE_METIERS',
    ESCAPEGAME = 'ESCAPE_GAME',
    EVENEMENTCINE = 'EVENEMENT_CINE',
    EVENEMENTJEU = 'EVENEMENT_JEU',
    EVENEMENTMUSIQUE = 'EVENEMENT_MUSIQUE',
    EVENEMENTPATRIMOINE = 'EVENEMENT_PATRIMOINE',
    FESTIVALCINE = 'FESTIVAL_CINE',
    FESTIVALLIVRE = 'FESTIVAL_LIVRE',
    FESTIVALMUSIQUE = 'FESTIVAL_MUSIQUE',
    FESTIVALSPECTACLE = 'FESTIVAL_SPECTACLE',
    JEUENLIGNE = 'JEU_EN_LIGNE',
    JEUSUPPORTPHYSIQUE = 'JEU_SUPPORT_PHYSIQUE',
    LIVESTREAMEVENEMENT = 'LIVESTREAM_EVENEMENT',
    LIVESTREAMMUSIQUE = 'LIVESTREAM_MUSIQUE',
    LIVESTREAMPRATIQUEARTISTIQUE = 'LIVESTREAM_PRATIQUE_ARTISTIQUE',
    LIVREAUDIOPHYSIQUE = 'LIVRE_AUDIO_PHYSIQUE',
    LIVRENUMERIQUE = 'LIVRE_NUMERIQUE',
    LIVREPAPIER = 'LIVRE_PAPIER',
    LOCATIONINSTRUMENT = 'LOCATION_INSTRUMENT',
    MATERIELARTCREATIF = 'MATERIEL_ART_CREATIF',
    MUSEEVENTEDISTANCE = 'MUSEE_VENTE_DISTANCE',
    OEUVREART = 'OEUVRE_ART',
    PARTITION = 'PARTITION',
    PLATEFORMEPRATIQUEARTISTIQUE = 'PLATEFORME_PRATIQUE_ARTISTIQUE',
    PRATIQUEARTVENTEDISTANCE = 'PRATIQUE_ART_VENTE_DISTANCE',
    PODCAST = 'PODCAST',
    RENCONTREENLIGNE = 'RENCONTRE_EN_LIGNE',
    RENCONTREJEU = 'RENCONTRE_JEU',
    RENCONTRE = 'RENCONTRE',
    SALON = 'SALON',
    SEANCECINE = 'SEANCE_CINE',
    SEANCEESSAIPRATIQUEART = 'SEANCE_ESSAI_PRATIQUE_ART',
    SPECTACLEENREGISTRE = 'SPECTACLE_ENREGISTRE',
    SPECTACLEREPRESENTATION = 'SPECTACLE_REPRESENTATION',
    SPECTACLEVENTEDISTANCE = 'SPECTACLE_VENTE_DISTANCE',
    SUPPORTPHYSIQUEFILM = 'SUPPORT_PHYSIQUE_FILM',
    SUPPORTPHYSIQUEMUSIQUE = 'SUPPORT_PHYSIQUE_MUSIQUE',
    TELECHARGEMENTLIVREAUDIO = 'TELECHARGEMENT_LIVRE_AUDIO',
    TELECHARGEMENTMUSIQUE = 'TELECHARGEMENT_MUSIQUE',
    VISITEGUIDEE = 'VISITE_GUIDEE',
    VISITEVIRTUELLE = 'VISITE_VIRTUELLE',
    VISITE = 'VISITE',
    VOD = 'VOD'
}
export interface SubcategoryResponseModel {
    appLabel: string;
    canBeDuo: boolean;
    canBeEducational: boolean;
    canExpire: boolean;
    categoryId: string;
    conditionalFields: Array<string>;
    id: string;
    isDigitalDeposit: boolean;
    isEvent: boolean;
    isPhysicalDeposit: boolean;
    isSelectable: boolean;
    onlineOfflinePlatform: string;
    proLabel: string;
    reimbursementRule: string;
    searchGroupName?: string | null;
}

export interface TransactionalNotificationData {
    extra?: any | null;
    groupId: string;
    message: TransactionalNotificationMessage;
    userIds: Array<number>;
}

export interface TransactionalNotificationMessage {
    body: string;
    title?: string | null;
}

export enum UbbleIdentificationStatus {
    Uninitiated = 'uninitiated',
    Initiated = 'initiated',
    Processing = 'processing',
    Processed = 'processed',
    Aborted = 'aborted',
    Expired = 'expired'
}
export interface UpdateBatchAttributesRequest {
    attributes: any;
    userId: number;
}

export interface UpdateProAttributesRequest {
    email: string;
    timeId: string;
}

export interface UpdateSendinblueContactRequest {
    attributes: any;
    contactListIds: Array<number>;
    email: string;
    emailBlacklisted: boolean;
}

export interface UserHasBookingResponse {
    hasBookings: boolean;
}

export interface UserOffererResponseModel {
    id: string;
    offererId: string;
    userId: string;
}

export enum UserRole {
    ADMIN = 'ADMIN',
    BENEFICIARY = 'BENEFICIARY',
    PRO = 'PRO',
    JOUVE = 'JOUVE',
    UNDERAGEBENEFICIARY = 'UNDERAGE_BENEFICIARY'
}
export interface ValidationError extends Array<ValidationErrorElement> {
}

export interface ValidationErrorElement {
    ctx?: any;
    loc: Array<string>;
    msg: string;
    type: string;
}

export interface VenueContactModel {
    email?: string | null;
    phoneNumber?: string | null;
    socialMedias?: { [key: string]: string; } | null;
    website?: string | null;
}

export interface VenueLabelListResponseModel extends Array<VenueLabelResponseModel> {
}

export interface VenueLabelResponseModel {
    id: string;
    label: string;
}

export interface VenueListItemResponseModel {
    audioDisabilityCompliant?: boolean | null;
    bookingEmail?: string | null;
    businessUnit?: BusinessUnitResponseModel | null;
    businessUnitId?: number | null;
    id: string;
    isBusinessUnitMainVenue?: boolean | null;
    isVirtual: boolean;
    managingOffererId: string;
    mentalDisabilityCompliant?: boolean | null;
    motorDisabilityCompliant?: boolean | null;
    name: string;
    offererName: string;
    publicName?: string | null;
    siret?: string | null;
    visualDisabilityCompliant?: boolean | null;
    withdrawalDetails?: string | null;
}

export interface VenueListQueryModel {
    activeOfferersOnly?: boolean | null;
    offererId?: number | null;
    validated?: boolean | null;
    validatedForUser?: boolean | null;
}

export interface VenueProviderResponse {
    dateModifiedAtLastProvider?: Date;
    fieldsUpdated: Array<string>;
    id: string;
    idAtProviders?: string;
    isActive: boolean;
    isDuo?: boolean;
    isFromAllocineProvider: boolean;
    lastProviderId?: string;
    lastSyncDate?: Date;
    nOffers: number;
    price?: number;
    provider: ProviderResponse;
    providerId: string;
    quantity?: number;
    venueId: string;
    venueIdAtOfferProvider: string;
}

export interface VenueResponseModel {
    id: string;
}

export interface VenueStatsResponseModel {
    activeBookingsQuantity: number;
    activeOffersCount: number;
    soldOutOffersCount: number;
    validatedBookingsQuantity: number;
}

export enum VenueTypeCode {
    ArtsVisuelsArtsPlastiquesEtGaleries = 'Arts visuels, arts plastiques et galeries',
    CentreCulturel = 'Centre culturel',
    CoursEtPratiqueArtistiques = 'Cours et pratique artistiques',
    CultureScientifique = 'Culture scientifique',
    Festival = 'Festival',
    JeuxJeuxVidos = 'Jeux / Jeux vidéos',
    Librairie = 'Librairie',
    BibliothqueOuMdiathque = 'Bibliothèque ou médiathèque',
    Muse = 'Musée',
    MusiqueDisquaire = 'Musique - Disquaire',
    MusiqueMagasinDinstruments = 'Musique - Magasin d’instruments',
    MusiqueSalleDeConcerts = 'Musique - Salle de concerts',
    OffreNumrique = 'Offre numérique',
    PatrimoineEtTourisme = 'Patrimoine et tourisme',
    CinmaSalleDeProjections = 'Cinéma - Salle de projections',
    SpectacleVivant = 'Spectacle vivant',
    MagasinArtsCratifs = 'Magasin arts créatifs',
    LieuAdministratif = 'Lieu administratif',
    Autre = 'Autre'
}
export interface VenueTypeListResponseModel extends Array<VenueTypeResponseModel> {
}

export interface VenueTypeResponseModel {
    id: string;
    label: string;
}

export interface WebhookDummyReponse {
    status?: string;
}

export interface WebhookRequest {
    configuration: Configuration;
    identificationId: string;
    status: UbbleIdentificationStatus;
}

export interface WebhookRequestHeaders {
    ubbleSignature: string;
}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: APIConfiguration) {
    return {
        /**
         * 
         * @summary delete_api_key <DELETE>
         * @param {string} apiKeyPrefix 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOfferersDeleteApiKey(apiKeyPrefix: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'apiKeyPrefix' is not null or undefined
            if (apiKeyPrefix === null || apiKeyPrefix === undefined) {
                throw new RequiredError('apiKeyPrefix','Required parameter apiKeyPrefix was null or undefined when calling deleteOfferersDeleteApiKey.');
            }
            const localVarPath = `/offerers/api_keys/{api_key_prefix}`
                .replace(`{${"api_key_prefix"}}`, encodeURIComponent(String(apiKeyPrefix)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'DELETE',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete_stock <DELETE>
         * @param {string} stockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStocksDeleteStock(stockId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'stockId' is not null or undefined
            if (stockId === null || stockId === undefined) {
                throw new RequiredError('stockId','Required parameter stockId was null or undefined when calling deleteStocksDeleteStock.');
            }
            const localVarPath = `/stocks/{stock_id}`
                .replace(`{${"stock_id"}}`, encodeURIComponent(String(stockId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'DELETE',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete_venue_banner <DELETE>
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVenuesDeleteVenueBanner(venueId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'venueId' is not null or undefined
            if (venueId === null || venueId === undefined) {
                throw new RequiredError('venueId','Required parameter venueId was null or undefined when calling deleteVenuesDeleteVenueBanner.');
            }
            const localVarPath = `/venues/{venue_id}/banner`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'DELETE',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_booking_by_token <GET>
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookingsGetBookingByToken(token: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getBookingsGetBookingByToken.');
            }
            const localVarPath = `/bookings/token/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_bookings_csv <GET>
         * @param {BookingStatusFilter} bookingStatusFilter 
         * @param {string} bookingPeriodBeginningDate 
         * @param {string} bookingPeriodEndingDate 
         * @param {number} [page] 
         * @param {number} [venueId] 
         * @param {Date} [eventDate] 
         * @param {OfferType} [offerType] 
         * @param {string} [extra] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookingsGetBookingsCsv(bookingStatusFilter: BookingStatusFilter, bookingPeriodBeginningDate: string, bookingPeriodEndingDate: string, page?: number, venueId?: number, eventDate?: Date, offerType?: OfferType, extra?: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'bookingStatusFilter' is not null or undefined
            if (bookingStatusFilter === null || bookingStatusFilter === undefined) {
                throw new RequiredError('bookingStatusFilter','Required parameter bookingStatusFilter was null or undefined when calling getBookingsGetBookingsCsv.');
            }
            // verify required parameter 'bookingPeriodBeginningDate' is not null or undefined
            if (bookingPeriodBeginningDate === null || bookingPeriodBeginningDate === undefined) {
                throw new RequiredError('bookingPeriodBeginningDate','Required parameter bookingPeriodBeginningDate was null or undefined when calling getBookingsGetBookingsCsv.');
            }
            // verify required parameter 'bookingPeriodEndingDate' is not null or undefined
            if (bookingPeriodEndingDate === null || bookingPeriodEndingDate === undefined) {
                throw new RequiredError('bookingPeriodEndingDate','Required parameter bookingPeriodEndingDate was null or undefined when calling getBookingsGetBookingsCsv.');
            }
            const localVarPath = `/bookings/csv`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (venueId !== undefined) {
                localVarQueryParameter['venueId'] = venueId;
            }
            if (eventDate !== undefined) {
                localVarQueryParameter['eventDate'] = (eventDate as any).toISOString();
            }
            if (bookingStatusFilter !== undefined) {
                localVarQueryParameter['bookingStatusFilter'] = bookingStatusFilter;
            }
            if (bookingPeriodBeginningDate !== undefined) {
                localVarQueryParameter['bookingPeriodBeginningDate'] = (bookingPeriodBeginningDate as any).toISOString();
            }
            if (bookingPeriodEndingDate !== undefined) {
                localVarQueryParameter['bookingPeriodEndingDate'] = (bookingPeriodEndingDate as any).toISOString();
            }
            if (offerType !== undefined) {
                localVarQueryParameter['offerType'] = offerType;
            }
            if (extra !== undefined) {
                localVarQueryParameter['extra'] = extra;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_bookings_pro <GET>
         * @param {BookingStatusFilter} bookingStatusFilter 
         * @param {string} bookingPeriodBeginningDate 
         * @param {string} bookingPeriodEndingDate 
         * @param {number} [page] 
         * @param {number} [venueId] 
         * @param {Date} [eventDate] 
         * @param {OfferType1} [offerType] 
         * @param {string} [extra] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookingsGetBookingsPro(bookingStatusFilter: BookingStatusFilter, bookingPeriodBeginningDate: string, bookingPeriodEndingDate: string, page?: number, venueId?: number, eventDate?: Date, offerType?: OfferType1, extra?: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'bookingStatusFilter' is not null or undefined
            if (bookingStatusFilter === null || bookingStatusFilter === undefined) {
                throw new RequiredError('bookingStatusFilter','Required parameter bookingStatusFilter was null or undefined when calling getBookingsGetBookingsPro.');
            }
            // verify required parameter 'bookingPeriodBeginningDate' is not null or undefined
            if (bookingPeriodBeginningDate === null || bookingPeriodBeginningDate === undefined) {
                throw new RequiredError('bookingPeriodBeginningDate','Required parameter bookingPeriodBeginningDate was null or undefined when calling getBookingsGetBookingsPro.');
            }
            // verify required parameter 'bookingPeriodEndingDate' is not null or undefined
            if (bookingPeriodEndingDate === null || bookingPeriodEndingDate === undefined) {
                throw new RequiredError('bookingPeriodEndingDate','Required parameter bookingPeriodEndingDate was null or undefined when calling getBookingsGetBookingsPro.');
            }
            const localVarPath = `/bookings/pro`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (venueId !== undefined) {
                localVarQueryParameter['venueId'] = venueId;
            }
            if (eventDate !== undefined) {
                localVarQueryParameter['eventDate'] = (eventDate as any).toISOString();
            }
            if (bookingStatusFilter !== undefined) {
                localVarQueryParameter['bookingStatusFilter'] = bookingStatusFilter;
            }
            if (bookingPeriodBeginningDate !== undefined) {
                localVarQueryParameter['bookingPeriodBeginningDate'] = (bookingPeriodBeginningDate as any).toISOString();
            }
            if (bookingPeriodEndingDate !== undefined) {
                localVarQueryParameter['bookingPeriodEndingDate'] = (bookingPeriodEndingDate as any).toISOString();
            }
            if (offerType !== undefined) {
                localVarQueryParameter['offerType'] = offerType;
            }
            if (extra !== undefined) {
                localVarQueryParameter['extra'] = extra;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_user_has_bookings <GET>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookingsGetUserHasBookings(options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/bookings/pro/userHasBookings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_business_units <GET>
         * @param {number} [offererId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinanceGetBusinessUnits(offererId?: number, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/finance/business-units`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (offererId !== undefined) {
                localVarQueryParameter['offererId'] = offererId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_invoices <GET>
         * @param {number} [businessUnitId] 
         * @param {string} [periodBeginningDate] 
         * @param {string} [periodEndingDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinanceGetInvoices(businessUnitId?: number, periodBeginningDate?: string, periodEndingDate?: string, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/finance/invoices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (businessUnitId !== undefined) {
                localVarQueryParameter['businessUnitId'] = businessUnitId;
            }
            if (periodBeginningDate !== undefined) {
                localVarQueryParameter['periodBeginningDate'] = (periodBeginningDate as any).toISOString();
            }
            if (periodEndingDate !== undefined) {
                localVarQueryParameter['periodEndingDate'] = (periodEndingDate as any).toISOString();
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary can_offerer_create_educational_offer <GET>
         * @param {string} humanizedOffererId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferersCanOffererCreateEducationalOffer(humanizedOffererId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'humanizedOffererId' is not null or undefined
            if (humanizedOffererId === null || humanizedOffererId === undefined) {
                throw new RequiredError('humanizedOffererId','Required parameter humanizedOffererId was null or undefined when calling getOfferersCanOffererCreateEducationalOffer.');
            }
            const localVarPath = `/offerers/{humanized_offerer_id}/eac-eligibility`
                .replace(`{${"humanized_offerer_id"}}`, encodeURIComponent(String(humanizedOffererId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_offerer <GET>
         * @param {string} offererId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferersGetOfferer(offererId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'offererId' is not null or undefined
            if (offererId === null || offererId === undefined) {
                throw new RequiredError('offererId','Required parameter offererId was null or undefined when calling getOfferersGetOfferer.');
            }
            const localVarPath = `/offerers/{offerer_id}`
                .replace(`{${"offerer_id"}}`, encodeURIComponent(String(offererId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_offerers <GET>
         * @param {string} [keywords] 
         * @param {number} [page] 
         * @param {number} [paginate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferersGetOfferers(keywords?: string, page?: number, paginate?: number, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/offerers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (paginate !== undefined) {
                localVarQueryParameter['paginate'] = paginate;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list_educational_offerers <GET>
         * @param {string} [offererId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferersListEducationalOfferers(offererId?: string, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/offerers/educational`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (offererId !== undefined) {
                localVarQueryParameter['offerer_id'] = offererId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list_offerers_names <GET>
         * @param {boolean} [validated] 
         * @param {boolean} [validatedForUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferersListOfferersNames(validated?: boolean, validatedForUser?: boolean, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/offerers/names`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (validated !== undefined) {
                localVarQueryParameter['validated'] = validated;
            }
            if (validatedForUser !== undefined) {
                localVarQueryParameter['validated_for_user'] = validatedForUser;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_categories <GET>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffersGetCategories(options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/offers/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_offer <GET>
         * @param {string} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffersGetOffer(offerId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'offerId' is not null or undefined
            if (offerId === null || offerId === undefined) {
                throw new RequiredError('offerId','Required parameter offerId was null or undefined when calling getOffersGetOffer.');
            }
            const localVarPath = `/offers/{offer_id}`
                .replace(`{${"offer_id"}}`, encodeURIComponent(String(offerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_stocks <GET>
         * @param {string} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffersGetStocks(offerId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'offerId' is not null or undefined
            if (offerId === null || offerId === undefined) {
                throw new RequiredError('offerId','Required parameter offerId was null or undefined when calling getOffersGetStocks.');
            }
            const localVarPath = `/offers/{offer_id}/stocks`
                .replace(`{${"offer_id"}}`, encodeURIComponent(String(offerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list_offers <GET>
         * @param {string} [nameOrIsbn] 
         * @param {number} [offererId] 
         * @param {string} [status] 
         * @param {number} [venueId] 
         * @param {string} [categoryId] 
         * @param {string} [creationMode] 
         * @param {string} [periodBeginningDate] 
         * @param {string} [periodEndingDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffersListOffers(nameOrIsbn?: string, offererId?: number, status?: string, venueId?: number, categoryId?: string, creationMode?: string, periodBeginningDate?: string, periodEndingDate?: string, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/offers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (nameOrIsbn !== undefined) {
                localVarQueryParameter['nameOrIsbn'] = nameOrIsbn;
            }
            if (offererId !== undefined) {
                localVarQueryParameter['offererId'] = offererId;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (venueId !== undefined) {
                localVarQueryParameter['venueId'] = venueId;
            }
            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }
            if (creationMode !== undefined) {
                localVarQueryParameter['creationMode'] = creationMode;
            }
            if (periodBeginningDate !== undefined) {
                localVarQueryParameter['periodBeginningDate'] = periodBeginningDate;
            }
            if (periodEndingDate !== undefined) {
                localVarQueryParameter['periodEndingDate'] = periodEndingDate;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Autocomplete offerers on name or SIREN.
         * @param {string} q 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPcOfferers(q: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling getPcOfferers.');
            }
            const localVarPath = `/pc/back-office/autocomplete/offerers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_reimbursements_csv <GET>
         * @param {string} [venueId] 
         * @param {string} [reimbursementPeriodBeginningDate] 
         * @param {string} [reimbursementPeriodEndingDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReimbursementsGetReimbursementsCsv(venueId?: string, reimbursementPeriodBeginningDate?: string, reimbursementPeriodEndingDate?: string, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/reimbursements/csv`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (venueId !== undefined) {
                localVarQueryParameter['venueId'] = venueId;
            }
            if (reimbursementPeriodBeginningDate !== undefined) {
                localVarQueryParameter['reimbursementPeriodBeginningDate'] = reimbursementPeriodBeginningDate;
            }
            if (reimbursementPeriodEndingDate !== undefined) {
                localVarQueryParameter['reimbursementPeriodEndingDate'] = reimbursementPeriodEndingDate;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_user_offerer <GET>
         * @param {string} offererId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserofferersGetUserOfferer(offererId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'offererId' is not null or undefined
            if (offererId === null || offererId === undefined) {
                throw new RequiredError('offererId','Required parameter offererId was null or undefined when calling getUserofferersGetUserOfferer.');
            }
            const localVarPath = `/userOfferers/{offerer_id}`
                .replace(`{${"offerer_id"}}`, encodeURIComponent(String(offererId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary check_activation_token_exists <GET>
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersCheckActivationTokenExists(token: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getUsersCheckActivationTokenExists.');
            }
            const localVarPath = `/users/token/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_profile <GET>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersGetProfile(options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary validate_new_offerer <GET>
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateValidateNewOfferer(token: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getValidateValidateNewOfferer.');
            }
            const localVarPath = `/validate/offerer/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary validate_offerer_attachment <GET>
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateValidateOffererAttachment(token: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getValidateValidateOffererAttachment.');
            }
            const localVarPath = `/validate/user-offerer/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary fetch_venue_labels <GET>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenueLabelsFetchVenueLabels(options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/venue-labels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_venue_types <GET>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenueTypesGetVenueTypes(options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/venue-types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list_venue_providers <GET>
         * @param {number} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenueprovidersListVenueProviders(venueId: number, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'venueId' is not null or undefined
            if (venueId === null || venueId === undefined) {
                throw new RequiredError('venueId','Required parameter venueId was null or undefined when calling getVenueprovidersListVenueProviders.');
            }
            const localVarPath = `/venueProviders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (venueId !== undefined) {
                localVarQueryParameter['venueId'] = venueId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_venue <GET>
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenuesGetVenue(venueId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'venueId' is not null or undefined
            if (venueId === null || venueId === undefined) {
                throw new RequiredError('venueId','Required parameter venueId was null or undefined when calling getVenuesGetVenue.');
            }
            const localVarPath = `/venues/{venue_id}`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_venue_stats <GET>
         * @param {string} humanizedVenueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenuesGetVenueStats(humanizedVenueId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'humanizedVenueId' is not null or undefined
            if (humanizedVenueId === null || humanizedVenueId === undefined) {
                throw new RequiredError('humanizedVenueId','Required parameter humanizedVenueId was null or undefined when calling getVenuesGetVenueStats.');
            }
            const localVarPath = `/venues/{humanized_venue_id}/stats`
                .replace(`{${"humanized_venue_id"}}`, encodeURIComponent(String(humanizedVenueId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get_venues <GET>
         * @param {boolean} [validatedForUser] 
         * @param {boolean} [validated] 
         * @param {boolean} [activeOfferersOnly] 
         * @param {number} [offererId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenuesGetVenues(validatedForUser?: boolean, validated?: boolean, activeOfferersOnly?: boolean, offererId?: number, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/venues`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'GET',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (validatedForUser !== undefined) {
                localVarQueryParameter['validatedForUser'] = validatedForUser;
            }
            if (validated !== undefined) {
                localVarQueryParameter['validated'] = validated;
            }
            if (activeOfferersOnly !== undefined) {
                localVarQueryParameter['activeOfferersOnly'] = activeOfferersOnly;
            }
            if (offererId !== undefined) {
                localVarQueryParameter['offererId'] = offererId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patch_booking_by_token <PATCH>
         * @param {string} token 
         * @param {string} [email] 
         * @param {string} [offerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBookingsPatchBookingByToken(token: string, email?: string, offerId?: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling patchBookingsPatchBookingByToken.');
            }
            const localVarPath = `/bookings/token/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            if (offerId !== undefined) {
                localVarQueryParameter['offer_id'] = offerId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary edit_business_unit <PATCH>
         * @param {number} businessUnitId 
         * @param {BusinessUnitEditionBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFinanceEditBusinessUnit(businessUnitId: number, body?: BusinessUnitEditionBodyModel, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'businessUnitId' is not null or undefined
            if (businessUnitId === null || businessUnitId === undefined) {
                throw new RequiredError('businessUnitId','Required parameter businessUnitId was null or undefined when calling patchFinanceEditBusinessUnit.');
            }
            const localVarPath = `/finance/business-units/{business_unit_id}`
                .replace(`{${"business_unit_id"}}`, encodeURIComponent(String(businessUnitId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BusinessUnitEditionBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel_educational_offer_booking <PATCH>
         * @param {string} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOffersCancelEducationalOfferBooking(offerId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'offerId' is not null or undefined
            if (offerId === null || offerId === undefined) {
                throw new RequiredError('offerId','Required parameter offerId was null or undefined when calling patchOffersCancelEducationalOfferBooking.');
            }
            const localVarPath = `/offers/{offer_id}/cancel_booking`
                .replace(`{${"offer_id"}}`, encodeURIComponent(String(offerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary edit_educational_offer <PATCH>
         * @param {string} offerId 
         * @param {PatchEducationalOfferBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOffersEditEducationalOffer(offerId: string, body?: PatchEducationalOfferBodyModel, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'offerId' is not null or undefined
            if (offerId === null || offerId === undefined) {
                throw new RequiredError('offerId','Required parameter offerId was null or undefined when calling patchOffersEditEducationalOffer.');
            }
            const localVarPath = `/offers/educational/{offer_id}`
                .replace(`{${"offer_id"}}`, encodeURIComponent(String(offerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchEducationalOfferBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patch_all_offers_active_status <PATCH>
         * @param {PatchAllOffersActiveStatusBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOffersPatchAllOffersActiveStatus(body?: PatchAllOffersActiveStatusBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/offers/all-active-status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchAllOffersActiveStatusBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patch_offer <PATCH>
         * @param {string} offerId 
         * @param {PatchOfferBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOffersPatchOffer(offerId: string, body?: PatchOfferBodyModel, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'offerId' is not null or undefined
            if (offerId === null || offerId === undefined) {
                throw new RequiredError('offerId','Required parameter offerId was null or undefined when calling patchOffersPatchOffer.');
            }
            const localVarPath = `/offers/{offer_id}`
                .replace(`{${"offer_id"}}`, encodeURIComponent(String(offerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchOfferBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patch_offers_active_status <PATCH>
         * @param {PatchOfferActiveStatusBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOffersPatchOffersActiveStatus(body?: PatchOfferActiveStatusBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/offers/active-status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchOfferActiveStatusBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary edit_educational_stock <PATCH>
         * @param {string} stockId 
         * @param {EducationalStockEditionBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStocksEditEducationalStock(stockId: string, body?: EducationalStockEditionBodyModel, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'stockId' is not null or undefined
            if (stockId === null || stockId === undefined) {
                throw new RequiredError('stockId','Required parameter stockId was null or undefined when calling patchStocksEditEducationalStock.');
            }
            const localVarPath = `/stocks/educational/{stock_id}`
                .replace(`{${"stock_id"}}`, encodeURIComponent(String(stockId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EducationalStockEditionBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary edit_shadow_stock <PATCH>
         * @param {string} stockId 
         * @param {EducationalOfferShadowStockBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStocksEditShadowStock(stockId: string, body?: EducationalOfferShadowStockBodyModel, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'stockId' is not null or undefined
            if (stockId === null || stockId === undefined) {
                throw new RequiredError('stockId','Required parameter stockId was null or undefined when calling patchStocksEditShadowStock.');
            }
            const localVarPath = `/stocks/shadow/{stock_id}`
                .replace(`{${"stock_id"}}`, encodeURIComponent(String(stockId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EducationalOfferShadowStockBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary transform_shadow_stock_into_educational_stock <PATCH>
         * @param {string} stockId 
         * @param {EducationalStockCreationBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStocksTransformShadowStockIntoEducationalStock(stockId: string, body?: EducationalStockCreationBodyModel, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'stockId' is not null or undefined
            if (stockId === null || stockId === undefined) {
                throw new RequiredError('stockId','Required parameter stockId was null or undefined when calling patchStocksTransformShadowStockIntoEducationalStock.');
            }
            const localVarPath = `/stocks/shadow-to-educational/{stock_id}`
                .replace(`{${"stock_id"}}`, encodeURIComponent(String(stockId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EducationalStockCreationBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patch_profile <PATCH>
         * @param {PatchProUserBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUsersPatchProfile(body?: PatchProUserBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/users/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchProUserBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patch_user_tuto_seen <PATCH>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUsersPatchUserTutoSeen(options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/users/tuto-seen`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary patch_user_tuto_seen_legacy <PATCH>
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUsersPatchUserTutoSeenLegacy(userId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling patchUsersPatchUserTutoSeenLegacy.');
            }
            const localVarPath = `/users/{user_id}/tuto-seen`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary validate_user <PATCH>
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchValidateValidateUser(token: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling patchValidateValidateUser.');
            }
            const localVarPath = `/validate/user/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary edit_venue <PATCH>
         * @param {string} venueId 
         * @param {EditVenueBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchVenuesEditVenue(venueId: string, body?: EditVenueBodyModel, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'venueId' is not null or undefined
            if (venueId === null || venueId === undefined) {
                throw new RequiredError('venueId','Required parameter venueId was null or undefined when calling patchVenuesEditVenue.');
            }
            const localVarPath = `/venues/{venue_id}`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PATCH',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EditVenueBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update_offerer_demarches_simplifiees_application <POST>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBankInformationsUpdateOffererDemarchesSimplifieesApplication(options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/bank_informations/offerer/application_update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update_venue_demarches_simplifiees_application <POST>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBankInformationsUpdateVenueDemarchesSimplifieesApplication(options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/bank_informations/venue/application_update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {UpdateBatchAttributesRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask(body?: UpdateBatchAttributesRequest, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/cloud-tasks/batch/android/update_user_attributes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateBatchAttributesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {DeleteBatchUserAttributesRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_1(body?: DeleteBatchUserAttributesRequest, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/cloud-tasks/batch/delete_user_attributes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteBatchUserAttributesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {UpdateBatchAttributesRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_2(body?: UpdateBatchAttributesRequest, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/cloud-tasks/batch/ios/update_user_attributes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateBatchAttributesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {TransactionalNotificationData} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_3(body?: TransactionalNotificationData, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/cloud-tasks/batch/send_transactional_notification`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransactionalNotificationData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {SendTransactionalEmailRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_4(body?: SendTransactionalEmailRequest, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/cloud-tasks/sendinblue/send-transactional-email-primary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SendTransactionalEmailRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {SendTransactionalEmailRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_5(body?: SendTransactionalEmailRequest, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/cloud-tasks/sendinblue/send-transactional-email-secondary`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SendTransactionalEmailRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {UpdateSendinblueContactRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_6(body?: UpdateSendinblueContactRequest, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/cloud-tasks/sendinblue/update_contact_attributes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateSendinblueContactRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {UpdateProAttributesRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_7(body?: UpdateProAttributesRequest, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/cloud-tasks/sendinblue/update_pro_attributes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateProAttributesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create_offerer <POST>
         * @param {CreateOffererQueryModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOfferersCreateOfferer(body?: CreateOffererQueryModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/offerers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateOffererQueryModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary generate_api_key_route <POST>
         * @param {string} offererId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOfferersGenerateApiKeyRoute(offererId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'offererId' is not null or undefined
            if (offererId === null || offererId === undefined) {
                throw new RequiredError('offererId','Required parameter offererId was null or undefined when calling postOfferersGenerateApiKeyRoute.');
            }
            const localVarPath = `/offerers/{offerer_id}/api_keys`
                .replace(`{${"offerer_id"}}`, encodeURIComponent(String(offererId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create_educational_offer <POST>
         * @param {PostEducationalOfferBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOffersCreateEducationalOffer(body?: PostEducationalOfferBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/offers/educational`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostEducationalOfferBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create_shadow_stock_for_educational_showcase_offer <POST>
         * @param {string} offerId 
         * @param {EducationalOfferShadowStockBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOffersCreateShadowStockForEducationalShowcaseOffer(offerId: string, body?: EducationalOfferShadowStockBodyModel, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'offerId' is not null or undefined
            if (offerId === null || offerId === undefined) {
                throw new RequiredError('offerId','Required parameter offerId was null or undefined when calling postOffersCreateShadowStockForEducationalShowcaseOffer.');
            }
            const localVarPath = `/offers/educational/{offer_id}/shadow-stock`
                .replace(`{${"offer_id"}}`, encodeURIComponent(String(offerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EducationalOfferShadowStockBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create_thumbnail <POST>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOffersCreateThumbnail(options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/offers/thumbnails/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post_offer <POST>
         * @param {PostOfferBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOffersPostOffer(body?: PostOfferBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/offers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostOfferBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create_educational_stock <POST>
         * @param {EducationalStockCreationBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStocksCreateEducationalStock(body?: EducationalStockCreationBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/stocks/educational`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EducationalStockCreationBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary upsert_stocks <POST>
         * @param {StocksUpsertBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStocksUpsertStocks(body?: StocksUpsertBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/stocks/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StocksUpsertBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post_change_password <POST>
         * @param {ChangePasswordBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersPostChangePassword(body?: ChangePasswordBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/users/current/change-password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangePasswordBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post_for_password_token <POST>
         * @param {ResetPasswordBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersPostForPasswordToken(body?: ResetPasswordBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/users/reset-password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetPasswordBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post_new_password <POST>
         * @param {NewPasswordBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersPostNewPassword(body?: NewPasswordBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/users/new-password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewPasswordBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signin <POST>
         * @param {LoginUserBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersSignin(body?: LoginUserBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/users/signin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginUserBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signup_pro <POST>
         * @param {ProUserCreationBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersSignupPro(body?: ProUserCreationBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/users/signup/pro`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProUserCreationBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create_venue_provider <POST>
         * @param {PostVenueProviderBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVenueprovidersCreateVenueProvider(body?: PostVenueProviderBody, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/venueProviders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostVenueProviderBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary post_create_venue <POST>
         * @param {PostVenueBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVenuesPostCreateVenue(body?: PostVenueBodyModel, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/venues`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostVenueBodyModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary upsert_venue_banner <POST>
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVenuesUpsertVenueBanner(venueId: string, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'venueId' is not null or undefined
            if (venueId === null || venueId === undefined) {
                throw new RequiredError('venueId','Required parameter venueId was null or undefined when calling postVenuesUpsertVenueBanner.');
            }
            const localVarPath = `/venues/{venue_id}/banner`
                .replace(`{${"venue_id"}}`, encodeURIComponent(String(venueId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary dms_webhook_update_application_status <POST>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksDmsWebhookUpdateApplicationStatus(options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/webhooks/dms/application_status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ubble_webhook_update_application_status <POST>
         * @param {string} ubbleSignature 
         * @param {WebhookRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksUbbleWebhookUpdateApplicationStatus(ubbleSignature: string, body?: WebhookRequest, options: any = {}): Promise<FetchArgs> {
            // verify required parameter 'ubbleSignature' is not null or undefined
            if (ubbleSignature === null || ubbleSignature === undefined) {
                throw new RequiredError('ubbleSignature','Required parameter ubbleSignature was null or undefined when calling postWebhooksUbbleWebhookUpdateApplicationStatus.');
            }
            const localVarPath = `/webhooks/ubble/application_status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (ubbleSignature !== undefined && ubbleSignature !== null) {
                localVarHeaderParameter['Ubble-Signature'] = String(ubbleSignature);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary unsubscribe_user <POST>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksUnsubscribeUser(options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/webhooks/sendinblue/unsubscribe`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'POST',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update_venue_provider <PUT>
         * @param {PostVenueProviderBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putVenueprovidersUpdateVenueProvider(body?: PostVenueProviderBody, options: any = {}): Promise<FetchArgs> {
            const localVarPath = `/venueProviders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({
                method: 'PUT',
                credentials: 'includes',
            }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostVenueProviderBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(api: DefaultApi, configuration?: APIConfiguration) {
    return {
        /**
         * 
         * @summary delete_api_key <DELETE>
         * @param {string} apiKeyPrefix 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOfferersDeleteApiKey(basePath: string, apiKeyPrefix: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).deleteOfferersDeleteApiKey(apiKeyPrefix, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary delete_stock <DELETE>
         * @param {string} stockId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStocksDeleteStock(basePath: string, stockId: string, options?: any): Promise<StockIdResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).deleteStocksDeleteStock(stockId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary delete_venue_banner <DELETE>
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVenuesDeleteVenueBanner(basePath: string, venueId: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).deleteVenuesDeleteVenueBanner(venueId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_booking_by_token <GET>
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookingsGetBookingByToken(basePath: string, token: string, options?: any): Promise<LegacyBookingResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getBookingsGetBookingByToken(token, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_bookings_csv <GET>
         * @param {BookingStatusFilter} bookingStatusFilter 
         * @param {string} bookingPeriodBeginningDate 
         * @param {string} bookingPeriodEndingDate 
         * @param {number} [page] 
         * @param {number} [venueId] 
         * @param {Date} [eventDate] 
         * @param {OfferType} [offerType] 
         * @param {string} [extra] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookingsGetBookingsCsv(basePath: string, bookingStatusFilter: BookingStatusFilter, bookingPeriodBeginningDate: string, bookingPeriodEndingDate: string, page?: number, venueId?: number, eventDate?: Date, offerType?: OfferType, extra?: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getBookingsGetBookingsCsv(bookingStatusFilter, bookingPeriodBeginningDate, bookingPeriodEndingDate, page, venueId, eventDate, offerType, extra, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_bookings_pro <GET>
         * @param {BookingStatusFilter} bookingStatusFilter 
         * @param {string} bookingPeriodBeginningDate 
         * @param {string} bookingPeriodEndingDate 
         * @param {number} [page] 
         * @param {number} [venueId] 
         * @param {Date} [eventDate] 
         * @param {OfferType1} [offerType] 
         * @param {string} [extra] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookingsGetBookingsPro(basePath: string, bookingStatusFilter: BookingStatusFilter, bookingPeriodBeginningDate: string, bookingPeriodEndingDate: string, page?: number, venueId?: number, eventDate?: Date, offerType?: OfferType1, extra?: string, options?: any): Promise<ListBookingsResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getBookingsGetBookingsPro(bookingStatusFilter, bookingPeriodBeginningDate, bookingPeriodEndingDate, page, venueId, eventDate, offerType, extra, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_user_has_bookings <GET>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookingsGetUserHasBookings(basePath: string, options?: any): Promise<UserHasBookingResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getBookingsGetUserHasBookings(options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_business_units <GET>
         * @param {number} [offererId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinanceGetBusinessUnits(basePath: string, offererId?: number, options?: any): Promise<BusinessUnitListResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getFinanceGetBusinessUnits(offererId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_invoices <GET>
         * @param {number} [businessUnitId] 
         * @param {string} [periodBeginningDate] 
         * @param {string} [periodEndingDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinanceGetInvoices(basePath: string, businessUnitId?: number, periodBeginningDate?: string, periodEndingDate?: string, options?: any): Promise<InvoiceListResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getFinanceGetInvoices(businessUnitId, periodBeginningDate, periodEndingDate, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary can_offerer_create_educational_offer <GET>
         * @param {string} humanizedOffererId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferersCanOffererCreateEducationalOffer(basePath: string, humanizedOffererId: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getOfferersCanOffererCreateEducationalOffer(humanizedOffererId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_offerer <GET>
         * @param {string} offererId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferersGetOfferer(basePath: string, offererId: string, options?: any): Promise<GetOffererResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getOfferersGetOfferer(offererId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_offerers <GET>
         * @param {string} [keywords] 
         * @param {number} [page] 
         * @param {number} [paginate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferersGetOfferers(basePath: string, keywords?: string, page?: number, paginate?: number, options?: any): Promise<GetOfferersListResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getOfferersGetOfferers(keywords, page, paginate, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary list_educational_offerers <GET>
         * @param {string} [offererId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferersListEducationalOfferers(basePath: string, offererId?: string, options?: any): Promise<GetEducationalOfferersResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getOfferersListEducationalOfferers(offererId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary list_offerers_names <GET>
         * @param {boolean} [validated] 
         * @param {boolean} [validatedForUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOfferersListOfferersNames(basePath: string, validated?: boolean, validatedForUser?: boolean, options?: any): Promise<GetOfferersNamesResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getOfferersListOfferersNames(validated, validatedForUser, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_categories <GET>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffersGetCategories(basePath: string, options?: any): Promise<CategoriesResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getOffersGetCategories(options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_offer <GET>
         * @param {string} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffersGetOffer(basePath: string, offerId: string, options?: any): Promise<GetOfferResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getOffersGetOffer(offerId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_stocks <GET>
         * @param {string} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffersGetStocks(basePath: string, offerId: string, options?: any): Promise<StocksResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getOffersGetStocks(offerId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary list_offers <GET>
         * @param {string} [nameOrIsbn] 
         * @param {number} [offererId] 
         * @param {string} [status] 
         * @param {number} [venueId] 
         * @param {string} [categoryId] 
         * @param {string} [creationMode] 
         * @param {string} [periodBeginningDate] 
         * @param {string} [periodEndingDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffersListOffers(basePath: string, nameOrIsbn?: string, offererId?: number, status?: string, venueId?: number, categoryId?: string, creationMode?: string, periodBeginningDate?: string, periodEndingDate?: string, options?: any): Promise<ListOffersResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getOffersListOffers(nameOrIsbn, offererId, status, venueId, categoryId, creationMode, periodBeginningDate, periodEndingDate, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary Autocomplete offerers on name or SIREN.
         * @param {string} q 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPcOfferers(basePath: string, q: string, options?: any): Promise<Select2Response> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getPcOfferers(q, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_reimbursements_csv <GET>
         * @param {string} [venueId] 
         * @param {string} [reimbursementPeriodBeginningDate] 
         * @param {string} [reimbursementPeriodEndingDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReimbursementsGetReimbursementsCsv(basePath: string, venueId?: string, reimbursementPeriodBeginningDate?: string, reimbursementPeriodEndingDate?: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getReimbursementsGetReimbursementsCsv(venueId, reimbursementPeriodBeginningDate, reimbursementPeriodEndingDate, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_user_offerer <GET>
         * @param {string} offererId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserofferersGetUserOfferer(basePath: string, offererId: string, options?: any): Promise<ListUserOfferersResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getUserofferersGetUserOfferer(offererId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary check_activation_token_exists <GET>
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersCheckActivationTokenExists(basePath: string, token: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getUsersCheckActivationTokenExists(token, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_profile <GET>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersGetProfile(basePath: string, options?: any): Promise<SharedCurrentUserResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getUsersGetProfile(options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary validate_new_offerer <GET>
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateValidateNewOfferer(basePath: string, token: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getValidateValidateNewOfferer(token, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary validate_offerer_attachment <GET>
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidateValidateOffererAttachment(basePath: string, token: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getValidateValidateOffererAttachment(token, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary fetch_venue_labels <GET>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenueLabelsFetchVenueLabels(basePath: string, options?: any): Promise<VenueLabelListResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getVenueLabelsFetchVenueLabels(options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_venue_types <GET>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenueTypesGetVenueTypes(basePath: string, options?: any): Promise<VenueTypeListResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getVenueTypesGetVenueTypes(options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary list_venue_providers <GET>
         * @param {number} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenueprovidersListVenueProviders(basePath: string, venueId: number, options?: any): Promise<ListVenueProviderResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getVenueprovidersListVenueProviders(venueId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_venue <GET>
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenuesGetVenue(basePath: string, venueId: string, options?: any): Promise<GetVenueResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getVenuesGetVenue(venueId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_venue_stats <GET>
         * @param {string} humanizedVenueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenuesGetVenueStats(basePath: string, humanizedVenueId: string, options?: any): Promise<VenueStatsResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getVenuesGetVenueStats(humanizedVenueId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary get_venues <GET>
         * @param {boolean} [validatedForUser] 
         * @param {boolean} [validated] 
         * @param {boolean} [activeOfferersOnly] 
         * @param {number} [offererId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVenuesGetVenues(basePath: string, validatedForUser?: boolean, validated?: boolean, activeOfferersOnly?: boolean, offererId?: number, options?: any): Promise<GetVenueListResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).getVenuesGetVenues(validatedForUser, validated, activeOfferersOnly, offererId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary patch_booking_by_token <PATCH>
         * @param {string} token 
         * @param {string} [email] 
         * @param {string} [offerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBookingsPatchBookingByToken(basePath: string, token: string, email?: string, offerId?: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchBookingsPatchBookingByToken(token, email, offerId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary edit_business_unit <PATCH>
         * @param {number} businessUnitId 
         * @param {BusinessUnitEditionBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFinanceEditBusinessUnit(basePath: string, businessUnitId: number, body?: BusinessUnitEditionBodyModel, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchFinanceEditBusinessUnit(businessUnitId, body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary cancel_educational_offer_booking <PATCH>
         * @param {string} offerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOffersCancelEducationalOfferBooking(basePath: string, offerId: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchOffersCancelEducationalOfferBooking(offerId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary edit_educational_offer <PATCH>
         * @param {string} offerId 
         * @param {PatchEducationalOfferBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOffersEditEducationalOffer(basePath: string, offerId: string, body?: PatchEducationalOfferBodyModel, options?: any): Promise<OfferResponseIdModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchOffersEditEducationalOffer(offerId, body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary patch_all_offers_active_status <PATCH>
         * @param {PatchAllOffersActiveStatusBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOffersPatchAllOffersActiveStatus(basePath: string, body?: PatchAllOffersActiveStatusBodyModel, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchOffersPatchAllOffersActiveStatus(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary patch_offer <PATCH>
         * @param {string} offerId 
         * @param {PatchOfferBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOffersPatchOffer(basePath: string, offerId: string, body?: PatchOfferBodyModel, options?: any): Promise<OfferResponseIdModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchOffersPatchOffer(offerId, body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary patch_offers_active_status <PATCH>
         * @param {PatchOfferActiveStatusBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOffersPatchOffersActiveStatus(basePath: string, body?: PatchOfferActiveStatusBodyModel, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchOffersPatchOffersActiveStatus(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary edit_educational_stock <PATCH>
         * @param {string} stockId 
         * @param {EducationalStockEditionBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStocksEditEducationalStock(basePath: string, stockId: string, body?: EducationalStockEditionBodyModel, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchStocksEditEducationalStock(stockId, body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary edit_shadow_stock <PATCH>
         * @param {string} stockId 
         * @param {EducationalOfferShadowStockBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStocksEditShadowStock(basePath: string, stockId: string, body?: EducationalOfferShadowStockBodyModel, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchStocksEditShadowStock(stockId, body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary transform_shadow_stock_into_educational_stock <PATCH>
         * @param {string} stockId 
         * @param {EducationalStockCreationBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStocksTransformShadowStockIntoEducationalStock(basePath: string, stockId: string, body?: EducationalStockCreationBodyModel, options?: any): Promise<StockEditionResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchStocksTransformShadowStockIntoEducationalStock(stockId, body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary patch_profile <PATCH>
         * @param {PatchProUserBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUsersPatchProfile(basePath: string, body?: PatchProUserBodyModel, options?: any): Promise<PatchProUserResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchUsersPatchProfile(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary patch_user_tuto_seen <PATCH>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUsersPatchUserTutoSeen(basePath: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchUsersPatchUserTutoSeen(options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary patch_user_tuto_seen_legacy <PATCH>
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUsersPatchUserTutoSeenLegacy(basePath: string, userId: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchUsersPatchUserTutoSeenLegacy(userId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary validate_user <PATCH>
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchValidateValidateUser(basePath: string, token: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchValidateValidateUser(token, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary edit_venue <PATCH>
         * @param {string} venueId 
         * @param {EditVenueBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchVenuesEditVenue(basePath: string, venueId: string, body?: EditVenueBodyModel, options?: any): Promise<GetVenueResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).patchVenuesEditVenue(venueId, body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary update_offerer_demarches_simplifiees_application <POST>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBankInformationsUpdateOffererDemarchesSimplifieesApplication(basePath: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postBankInformationsUpdateOffererDemarchesSimplifieesApplication(options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary update_venue_demarches_simplifiees_application <POST>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBankInformationsUpdateVenueDemarchesSimplifieesApplication(basePath: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postBankInformationsUpdateVenueDemarchesSimplifieesApplication(options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {UpdateBatchAttributesRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask(basePath: string, body?: UpdateBatchAttributesRequest, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postCloudTasksHandleTask(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {DeleteBatchUserAttributesRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_1(basePath: string, body?: DeleteBatchUserAttributesRequest, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postCloudTasksHandleTask_1(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {UpdateBatchAttributesRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_2(basePath: string, body?: UpdateBatchAttributesRequest, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postCloudTasksHandleTask_2(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {TransactionalNotificationData} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_3(basePath: string, body?: TransactionalNotificationData, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postCloudTasksHandleTask_3(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {SendTransactionalEmailRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_4(basePath: string, body?: SendTransactionalEmailRequest, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postCloudTasksHandleTask_4(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {SendTransactionalEmailRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_5(basePath: string, body?: SendTransactionalEmailRequest, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postCloudTasksHandleTask_5(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {UpdateSendinblueContactRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_6(basePath: string, body?: UpdateSendinblueContactRequest, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postCloudTasksHandleTask_6(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary handle_task <POST>
         * @param {UpdateProAttributesRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCloudTasksHandleTask_7(basePath: string, body?: UpdateProAttributesRequest, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postCloudTasksHandleTask_7(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary create_offerer <POST>
         * @param {CreateOffererQueryModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOfferersCreateOfferer(basePath: string, body?: CreateOffererQueryModel, options?: any): Promise<GetOffererResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postOfferersCreateOfferer(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary generate_api_key_route <POST>
         * @param {string} offererId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOfferersGenerateApiKeyRoute(basePath: string, offererId: string, options?: any): Promise<GenerateOffererApiKeyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postOfferersGenerateApiKeyRoute(offererId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary create_educational_offer <POST>
         * @param {PostEducationalOfferBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOffersCreateEducationalOffer(basePath: string, body?: PostEducationalOfferBodyModel, options?: any): Promise<OfferResponseIdModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postOffersCreateEducationalOffer(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary create_shadow_stock_for_educational_showcase_offer <POST>
         * @param {string} offerId 
         * @param {EducationalOfferShadowStockBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOffersCreateShadowStockForEducationalShowcaseOffer(basePath: string, offerId: string, body?: EducationalOfferShadowStockBodyModel, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postOffersCreateShadowStockForEducationalShowcaseOffer(offerId, body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary create_thumbnail <POST>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOffersCreateThumbnail(basePath: string, options?: any): Promise<CreateThumbnailResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postOffersCreateThumbnail(options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary post_offer <POST>
         * @param {PostOfferBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOffersPostOffer(basePath: string, body?: PostOfferBodyModel, options?: any): Promise<OfferResponseIdModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postOffersPostOffer(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary create_educational_stock <POST>
         * @param {EducationalStockCreationBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStocksCreateEducationalStock(basePath: string, body?: EducationalStockCreationBodyModel, options?: any): Promise<StockIdResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postStocksCreateEducationalStock(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary upsert_stocks <POST>
         * @param {StocksUpsertBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStocksUpsertStocks(basePath: string, body?: StocksUpsertBodyModel, options?: any): Promise<StockIdsResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postStocksUpsertStocks(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary post_change_password <POST>
         * @param {ChangePasswordBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersPostChangePassword(basePath: string, body?: ChangePasswordBodyModel, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postUsersPostChangePassword(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary post_for_password_token <POST>
         * @param {ResetPasswordBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersPostForPasswordToken(basePath: string, body?: ResetPasswordBodyModel, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postUsersPostForPasswordToken(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary post_new_password <POST>
         * @param {NewPasswordBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersPostNewPassword(basePath: string, body?: NewPasswordBodyModel, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postUsersPostNewPassword(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary signin <POST>
         * @param {LoginUserBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersSignin(basePath: string, body?: LoginUserBodyModel, options?: any): Promise<SharedLoginUserResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postUsersSignin(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary signup_pro <POST>
         * @param {ProUserCreationBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersSignupPro(basePath: string, body?: ProUserCreationBodyModel, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postUsersSignupPro(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary create_venue_provider <POST>
         * @param {PostVenueProviderBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVenueprovidersCreateVenueProvider(basePath: string, body?: PostVenueProviderBody, options?: any): Promise<VenueProviderResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postVenueprovidersCreateVenueProvider(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary post_create_venue <POST>
         * @param {PostVenueBodyModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVenuesPostCreateVenue(basePath: string, body?: PostVenueBodyModel, options?: any): Promise<VenueResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postVenuesPostCreateVenue(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary upsert_venue_banner <POST>
         * @param {string} venueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVenuesUpsertVenueBanner(basePath: string, venueId: string, options?: any): Promise<GetVenueResponseModel> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postVenuesUpsertVenueBanner(venueId, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary dms_webhook_update_application_status <POST>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksDmsWebhookUpdateApplicationStatus(basePath: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postWebhooksDmsWebhookUpdateApplicationStatus(options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary ubble_webhook_update_application_status <POST>
         * @param {string} ubbleSignature 
         * @param {WebhookRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksUbbleWebhookUpdateApplicationStatus(basePath: string, ubbleSignature: string, body?: WebhookRequest, options?: any): Promise<WebhookDummyReponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postWebhooksUbbleWebhookUpdateApplicationStatus(ubbleSignature, body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary unsubscribe_user <POST>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksUnsubscribeUser(basePath: string, options?: any): Promise<EmptyResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).postWebhooksUnsubscribeUser(options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
        /**
         * 
         * @summary update_venue_provider <PUT>
         * @param {PostVenueProviderBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putVenueprovidersUpdateVenueProvider(basePath: string, body?: PostVenueProviderBody, options?: any): Promise<VenueProviderResponse> {
            const localVarFetchArgs = await DefaultApiFetchParamCreator(configuration).putVenueprovidersUpdateVenueProvider(body, options);
            const response = await safeFetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
            return handleGeneratedApiResponse(response)
        },
    }
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * 
     * @summary delete_api_key <DELETE>
     * @param {string} apiKeyPrefix 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteOfferersDeleteApiKey(apiKeyPrefix: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary delete_stock <DELETE>
     * @param {string} stockId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteStocksDeleteStock(stockId: string, options?: any): Promise<StockIdResponseModel>;

    /**
     * 
     * @summary delete_venue_banner <DELETE>
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteVenuesDeleteVenueBanner(venueId: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary get_booking_by_token <GET>
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getBookingsGetBookingByToken(token: string, options?: any): Promise<LegacyBookingResponse>;

    /**
     * 
     * @summary get_bookings_csv <GET>
     * @param {BookingStatusFilter} bookingStatusFilter 
     * @param {string} bookingPeriodBeginningDate 
     * @param {string} bookingPeriodEndingDate 
     * @param {number} [page] 
     * @param {number} [venueId] 
     * @param {Date} [eventDate] 
     * @param {OfferType} [offerType] 
     * @param {string} [extra] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getBookingsGetBookingsCsv(bookingStatusFilter: BookingStatusFilter, bookingPeriodBeginningDate: string, bookingPeriodEndingDate: string, page?: number, venueId?: number, eventDate?: Date, offerType?: OfferType, extra?: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary get_bookings_pro <GET>
     * @param {BookingStatusFilter} bookingStatusFilter 
     * @param {string} bookingPeriodBeginningDate 
     * @param {string} bookingPeriodEndingDate 
     * @param {number} [page] 
     * @param {number} [venueId] 
     * @param {Date} [eventDate] 
     * @param {OfferType1} [offerType] 
     * @param {string} [extra] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getBookingsGetBookingsPro(bookingStatusFilter: BookingStatusFilter, bookingPeriodBeginningDate: string, bookingPeriodEndingDate: string, page?: number, venueId?: number, eventDate?: Date, offerType?: OfferType1, extra?: string, options?: any): Promise<ListBookingsResponseModel>;

    /**
     * 
     * @summary get_user_has_bookings <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getBookingsGetUserHasBookings(options?: any): Promise<UserHasBookingResponse>;

    /**
     * 
     * @summary get_business_units <GET>
     * @param {number} [offererId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getFinanceGetBusinessUnits(offererId?: number, options?: any): Promise<BusinessUnitListResponseModel>;

    /**
     * 
     * @summary get_invoices <GET>
     * @param {number} [businessUnitId] 
     * @param {string} [periodBeginningDate] 
     * @param {string} [periodEndingDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getFinanceGetInvoices(businessUnitId?: number, periodBeginningDate?: string, periodEndingDate?: string, options?: any): Promise<InvoiceListResponseModel>;

    /**
     * 
     * @summary can_offerer_create_educational_offer <GET>
     * @param {string} humanizedOffererId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getOfferersCanOffererCreateEducationalOffer(humanizedOffererId: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary get_offerer <GET>
     * @param {string} offererId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getOfferersGetOfferer(offererId: string, options?: any): Promise<GetOffererResponseModel>;

    /**
     * 
     * @summary get_offerers <GET>
     * @param {string} [keywords] 
     * @param {number} [page] 
     * @param {number} [paginate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getOfferersGetOfferers(keywords?: string, page?: number, paginate?: number, options?: any): Promise<GetOfferersListResponseModel>;

    /**
     * 
     * @summary list_educational_offerers <GET>
     * @param {string} [offererId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getOfferersListEducationalOfferers(offererId?: string, options?: any): Promise<GetEducationalOfferersResponseModel>;

    /**
     * 
     * @summary list_offerers_names <GET>
     * @param {boolean} [validated] 
     * @param {boolean} [validatedForUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getOfferersListOfferersNames(validated?: boolean, validatedForUser?: boolean, options?: any): Promise<GetOfferersNamesResponseModel>;

    /**
     * 
     * @summary get_categories <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getOffersGetCategories(options?: any): Promise<CategoriesResponseModel>;

    /**
     * 
     * @summary get_offer <GET>
     * @param {string} offerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getOffersGetOffer(offerId: string, options?: any): Promise<GetOfferResponseModel>;

    /**
     * 
     * @summary get_stocks <GET>
     * @param {string} offerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getOffersGetStocks(offerId: string, options?: any): Promise<StocksResponseModel>;

    /**
     * 
     * @summary list_offers <GET>
     * @param {string} [nameOrIsbn] 
     * @param {number} [offererId] 
     * @param {string} [status] 
     * @param {number} [venueId] 
     * @param {string} [categoryId] 
     * @param {string} [creationMode] 
     * @param {string} [periodBeginningDate] 
     * @param {string} [periodEndingDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getOffersListOffers(nameOrIsbn?: string, offererId?: number, status?: string, venueId?: number, categoryId?: string, creationMode?: string, periodBeginningDate?: string, periodEndingDate?: string, options?: any): Promise<ListOffersResponseModel>;

    /**
     * 
     * @summary Autocomplete offerers on name or SIREN.
     * @param {string} q 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getPcOfferers(q: string, options?: any): Promise<Select2Response>;

    /**
     * 
     * @summary get_reimbursements_csv <GET>
     * @param {string} [venueId] 
     * @param {string} [reimbursementPeriodBeginningDate] 
     * @param {string} [reimbursementPeriodEndingDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getReimbursementsGetReimbursementsCsv(venueId?: string, reimbursementPeriodBeginningDate?: string, reimbursementPeriodEndingDate?: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary get_user_offerer <GET>
     * @param {string} offererId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getUserofferersGetUserOfferer(offererId: string, options?: any): Promise<ListUserOfferersResponseModel>;

    /**
     * 
     * @summary check_activation_token_exists <GET>
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getUsersCheckActivationTokenExists(token: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary get_profile <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getUsersGetProfile(options?: any): Promise<SharedCurrentUserResponseModel>;

    /**
     * 
     * @summary validate_new_offerer <GET>
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getValidateValidateNewOfferer(token: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary validate_offerer_attachment <GET>
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getValidateValidateOffererAttachment(token: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary fetch_venue_labels <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getVenueLabelsFetchVenueLabels(options?: any): Promise<VenueLabelListResponseModel>;

    /**
     * 
     * @summary get_venue_types <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getVenueTypesGetVenueTypes(options?: any): Promise<VenueTypeListResponseModel>;

    /**
     * 
     * @summary list_venue_providers <GET>
     * @param {number} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getVenueprovidersListVenueProviders(venueId: number, options?: any): Promise<ListVenueProviderResponse>;

    /**
     * 
     * @summary get_venue <GET>
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getVenuesGetVenue(venueId: string, options?: any): Promise<GetVenueResponseModel>;

    /**
     * 
     * @summary get_venue_stats <GET>
     * @param {string} humanizedVenueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getVenuesGetVenueStats(humanizedVenueId: string, options?: any): Promise<VenueStatsResponseModel>;

    /**
     * 
     * @summary get_venues <GET>
     * @param {boolean} [validatedForUser] 
     * @param {boolean} [validated] 
     * @param {boolean} [activeOfferersOnly] 
     * @param {number} [offererId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getVenuesGetVenues(validatedForUser?: boolean, validated?: boolean, activeOfferersOnly?: boolean, offererId?: number, options?: any): Promise<GetVenueListResponseModel>;

    /**
     * 
     * @summary patch_booking_by_token <PATCH>
     * @param {string} token 
     * @param {string} [email] 
     * @param {string} [offerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchBookingsPatchBookingByToken(token: string, email?: string, offerId?: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary edit_business_unit <PATCH>
     * @param {number} businessUnitId 
     * @param {BusinessUnitEditionBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchFinanceEditBusinessUnit(businessUnitId: number, body?: BusinessUnitEditionBodyModel, options?: any): Promise<{}>;

    /**
     * 
     * @summary cancel_educational_offer_booking <PATCH>
     * @param {string} offerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchOffersCancelEducationalOfferBooking(offerId: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary edit_educational_offer <PATCH>
     * @param {string} offerId 
     * @param {PatchEducationalOfferBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchOffersEditEducationalOffer(offerId: string, body?: PatchEducationalOfferBodyModel, options?: any): Promise<OfferResponseIdModel>;

    /**
     * 
     * @summary patch_all_offers_active_status <PATCH>
     * @param {PatchAllOffersActiveStatusBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchOffersPatchAllOffersActiveStatus(body?: PatchAllOffersActiveStatusBodyModel, options?: any): Promise<{}>;

    /**
     * 
     * @summary patch_offer <PATCH>
     * @param {string} offerId 
     * @param {PatchOfferBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchOffersPatchOffer(offerId: string, body?: PatchOfferBodyModel, options?: any): Promise<OfferResponseIdModel>;

    /**
     * 
     * @summary patch_offers_active_status <PATCH>
     * @param {PatchOfferActiveStatusBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchOffersPatchOffersActiveStatus(body?: PatchOfferActiveStatusBodyModel, options?: any): Promise<{}>;

    /**
     * 
     * @summary edit_educational_stock <PATCH>
     * @param {string} stockId 
     * @param {EducationalStockEditionBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchStocksEditEducationalStock(stockId: string, body?: EducationalStockEditionBodyModel, options?: any): Promise<{}>;

    /**
     * 
     * @summary edit_shadow_stock <PATCH>
     * @param {string} stockId 
     * @param {EducationalOfferShadowStockBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchStocksEditShadowStock(stockId: string, body?: EducationalOfferShadowStockBodyModel, options?: any): Promise<{}>;

    /**
     * 
     * @summary transform_shadow_stock_into_educational_stock <PATCH>
     * @param {string} stockId 
     * @param {EducationalStockCreationBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchStocksTransformShadowStockIntoEducationalStock(stockId: string, body?: EducationalStockCreationBodyModel, options?: any): Promise<StockEditionResponseModel>;

    /**
     * 
     * @summary patch_profile <PATCH>
     * @param {PatchProUserBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchUsersPatchProfile(body?: PatchProUserBodyModel, options?: any): Promise<PatchProUserResponseModel>;

    /**
     * 
     * @summary patch_user_tuto_seen <PATCH>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchUsersPatchUserTutoSeen(options?: any): Promise<{}>;

    /**
     * 
     * @summary patch_user_tuto_seen_legacy <PATCH>
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchUsersPatchUserTutoSeenLegacy(userId: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary validate_user <PATCH>
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchValidateValidateUser(token: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary edit_venue <PATCH>
     * @param {string} venueId 
     * @param {EditVenueBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    patchVenuesEditVenue(venueId: string, body?: EditVenueBodyModel, options?: any): Promise<GetVenueResponseModel>;

    /**
     * 
     * @summary update_offerer_demarches_simplifiees_application <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postBankInformationsUpdateOffererDemarchesSimplifieesApplication(options?: any): Promise<{}>;

    /**
     * 
     * @summary update_venue_demarches_simplifiees_application <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postBankInformationsUpdateVenueDemarchesSimplifieesApplication(options?: any): Promise<{}>;

    /**
     * 
     * @summary handle_task <POST>
     * @param {UpdateBatchAttributesRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCloudTasksHandleTask(body?: UpdateBatchAttributesRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary handle_task <POST>
     * @param {DeleteBatchUserAttributesRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCloudTasksHandleTask_1(body?: DeleteBatchUserAttributesRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary handle_task <POST>
     * @param {UpdateBatchAttributesRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCloudTasksHandleTask_2(body?: UpdateBatchAttributesRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary handle_task <POST>
     * @param {TransactionalNotificationData} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCloudTasksHandleTask_3(body?: TransactionalNotificationData, options?: any): Promise<{}>;

    /**
     * 
     * @summary handle_task <POST>
     * @param {SendTransactionalEmailRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCloudTasksHandleTask_4(body?: SendTransactionalEmailRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary handle_task <POST>
     * @param {SendTransactionalEmailRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCloudTasksHandleTask_5(body?: SendTransactionalEmailRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary handle_task <POST>
     * @param {UpdateSendinblueContactRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCloudTasksHandleTask_6(body?: UpdateSendinblueContactRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary handle_task <POST>
     * @param {UpdateProAttributesRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postCloudTasksHandleTask_7(body?: UpdateProAttributesRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary create_offerer <POST>
     * @param {CreateOffererQueryModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postOfferersCreateOfferer(body?: CreateOffererQueryModel, options?: any): Promise<GetOffererResponseModel>;

    /**
     * 
     * @summary generate_api_key_route <POST>
     * @param {string} offererId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postOfferersGenerateApiKeyRoute(offererId: string, options?: any): Promise<GenerateOffererApiKeyResponse>;

    /**
     * 
     * @summary create_educational_offer <POST>
     * @param {PostEducationalOfferBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postOffersCreateEducationalOffer(body?: PostEducationalOfferBodyModel, options?: any): Promise<OfferResponseIdModel>;

    /**
     * 
     * @summary create_shadow_stock_for_educational_showcase_offer <POST>
     * @param {string} offerId 
     * @param {EducationalOfferShadowStockBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postOffersCreateShadowStockForEducationalShowcaseOffer(offerId: string, body?: EducationalOfferShadowStockBodyModel, options?: any): Promise<{}>;

    /**
     * 
     * @summary create_thumbnail <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postOffersCreateThumbnail(options?: any): Promise<CreateThumbnailResponseModel>;

    /**
     * 
     * @summary post_offer <POST>
     * @param {PostOfferBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postOffersPostOffer(body?: PostOfferBodyModel, options?: any): Promise<OfferResponseIdModel>;

    /**
     * 
     * @summary create_educational_stock <POST>
     * @param {EducationalStockCreationBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postStocksCreateEducationalStock(body?: EducationalStockCreationBodyModel, options?: any): Promise<StockIdResponseModel>;

    /**
     * 
     * @summary upsert_stocks <POST>
     * @param {StocksUpsertBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postStocksUpsertStocks(body?: StocksUpsertBodyModel, options?: any): Promise<StockIdsResponseModel>;

    /**
     * 
     * @summary post_change_password <POST>
     * @param {ChangePasswordBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postUsersPostChangePassword(body?: ChangePasswordBodyModel, options?: any): Promise<{}>;

    /**
     * 
     * @summary post_for_password_token <POST>
     * @param {ResetPasswordBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postUsersPostForPasswordToken(body?: ResetPasswordBodyModel, options?: any): Promise<{}>;

    /**
     * 
     * @summary post_new_password <POST>
     * @param {NewPasswordBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postUsersPostNewPassword(body?: NewPasswordBodyModel, options?: any): Promise<{}>;

    /**
     * 
     * @summary signin <POST>
     * @param {LoginUserBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postUsersSignin(body?: LoginUserBodyModel, options?: any): Promise<SharedLoginUserResponseModel>;

    /**
     * 
     * @summary signup_pro <POST>
     * @param {ProUserCreationBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postUsersSignupPro(body?: ProUserCreationBodyModel, options?: any): Promise<{}>;

    /**
     * 
     * @summary create_venue_provider <POST>
     * @param {PostVenueProviderBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postVenueprovidersCreateVenueProvider(body?: PostVenueProviderBody, options?: any): Promise<VenueProviderResponse>;

    /**
     * 
     * @summary post_create_venue <POST>
     * @param {PostVenueBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postVenuesPostCreateVenue(body?: PostVenueBodyModel, options?: any): Promise<VenueResponseModel>;

    /**
     * 
     * @summary upsert_venue_banner <POST>
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postVenuesUpsertVenueBanner(venueId: string, options?: any): Promise<GetVenueResponseModel>;

    /**
     * 
     * @summary dms_webhook_update_application_status <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postWebhooksDmsWebhookUpdateApplicationStatus(options?: any): Promise<{}>;

    /**
     * 
     * @summary ubble_webhook_update_application_status <POST>
     * @param {string} ubbleSignature 
     * @param {WebhookRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postWebhooksUbbleWebhookUpdateApplicationStatus(ubbleSignature: string, body?: WebhookRequest, options?: any): Promise<WebhookDummyReponse>;

    /**
     * 
     * @summary unsubscribe_user <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    postWebhooksUnsubscribeUser(options?: any): Promise<{}>;

    /**
     * 
     * @summary update_venue_provider <PUT>
     * @param {PostVenueProviderBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    putVenueprovidersUpdateVenueProvider(body?: PostVenueProviderBody, options?: any): Promise<VenueProviderResponse>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * 
     * @summary delete_api_key <DELETE>
     * @param {string} apiKeyPrefix 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async deleteOfferersDeleteApiKey(apiKeyPrefix: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.deleteOfferersDeleteApiKey(this.basePath, apiKeyPrefix, options)
    }
    /**
     * 
     * @summary delete_stock <DELETE>
     * @param {string} stockId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async deleteStocksDeleteStock(stockId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.deleteStocksDeleteStock(this.basePath, stockId, options)
    }
    /**
     * 
     * @summary delete_venue_banner <DELETE>
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async deleteVenuesDeleteVenueBanner(venueId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.deleteVenuesDeleteVenueBanner(this.basePath, venueId, options)
    }
    /**
     * 
     * @summary get_booking_by_token <GET>
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getBookingsGetBookingByToken(token: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getBookingsGetBookingByToken(this.basePath, token, options)
    }
    /**
     * 
     * @summary get_bookings_csv <GET>
     * @param {BookingStatusFilter} bookingStatusFilter 
     * @param {string} bookingPeriodBeginningDate 
     * @param {string} bookingPeriodEndingDate 
     * @param {number} [page] 
     * @param {number} [venueId] 
     * @param {Date} [eventDate] 
     * @param {OfferType} [offerType] 
     * @param {string} [extra] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getBookingsGetBookingsCsv(bookingStatusFilter: BookingStatusFilter, bookingPeriodBeginningDate: string, bookingPeriodEndingDate: string, page?: number, venueId?: number, eventDate?: Date, offerType?: OfferType, extra?: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getBookingsGetBookingsCsv(this.basePath, bookingStatusFilter, bookingPeriodBeginningDate, bookingPeriodEndingDate, page, venueId, eventDate, offerType, extra, options)
    }
    /**
     * 
     * @summary get_bookings_pro <GET>
     * @param {BookingStatusFilter} bookingStatusFilter 
     * @param {string} bookingPeriodBeginningDate 
     * @param {string} bookingPeriodEndingDate 
     * @param {number} [page] 
     * @param {number} [venueId] 
     * @param {Date} [eventDate] 
     * @param {OfferType1} [offerType] 
     * @param {string} [extra] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getBookingsGetBookingsPro(bookingStatusFilter: BookingStatusFilter, bookingPeriodBeginningDate: string, bookingPeriodEndingDate: string, page?: number, venueId?: number, eventDate?: Date, offerType?: OfferType1, extra?: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getBookingsGetBookingsPro(this.basePath, bookingStatusFilter, bookingPeriodBeginningDate, bookingPeriodEndingDate, page, venueId, eventDate, offerType, extra, options)
    }
    /**
     * 
     * @summary get_user_has_bookings <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getBookingsGetUserHasBookings(options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getBookingsGetUserHasBookings(this.basePath, options)
    }
    /**
     * 
     * @summary get_business_units <GET>
     * @param {number} [offererId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getFinanceGetBusinessUnits(offererId?: number, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getFinanceGetBusinessUnits(this.basePath, offererId, options)
    }
    /**
     * 
     * @summary get_invoices <GET>
     * @param {number} [businessUnitId] 
     * @param {string} [periodBeginningDate] 
     * @param {string} [periodEndingDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getFinanceGetInvoices(businessUnitId?: number, periodBeginningDate?: string, periodEndingDate?: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getFinanceGetInvoices(this.basePath, businessUnitId, periodBeginningDate, periodEndingDate, options)
    }
    /**
     * 
     * @summary can_offerer_create_educational_offer <GET>
     * @param {string} humanizedOffererId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getOfferersCanOffererCreateEducationalOffer(humanizedOffererId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getOfferersCanOffererCreateEducationalOffer(this.basePath, humanizedOffererId, options)
    }
    /**
     * 
     * @summary get_offerer <GET>
     * @param {string} offererId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getOfferersGetOfferer(offererId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getOfferersGetOfferer(this.basePath, offererId, options)
    }
    /**
     * 
     * @summary get_offerers <GET>
     * @param {string} [keywords] 
     * @param {number} [page] 
     * @param {number} [paginate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getOfferersGetOfferers(keywords?: string, page?: number, paginate?: number, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getOfferersGetOfferers(this.basePath, keywords, page, paginate, options)
    }
    /**
     * 
     * @summary list_educational_offerers <GET>
     * @param {string} [offererId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getOfferersListEducationalOfferers(offererId?: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getOfferersListEducationalOfferers(this.basePath, offererId, options)
    }
    /**
     * 
     * @summary list_offerers_names <GET>
     * @param {boolean} [validated] 
     * @param {boolean} [validatedForUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getOfferersListOfferersNames(validated?: boolean, validatedForUser?: boolean, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getOfferersListOfferersNames(this.basePath, validated, validatedForUser, options)
    }
    /**
     * 
     * @summary get_categories <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getOffersGetCategories(options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getOffersGetCategories(this.basePath, options)
    }
    /**
     * 
     * @summary get_offer <GET>
     * @param {string} offerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getOffersGetOffer(offerId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getOffersGetOffer(this.basePath, offerId, options)
    }
    /**
     * 
     * @summary get_stocks <GET>
     * @param {string} offerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getOffersGetStocks(offerId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getOffersGetStocks(this.basePath, offerId, options)
    }
    /**
     * 
     * @summary list_offers <GET>
     * @param {string} [nameOrIsbn] 
     * @param {number} [offererId] 
     * @param {string} [status] 
     * @param {number} [venueId] 
     * @param {string} [categoryId] 
     * @param {string} [creationMode] 
     * @param {string} [periodBeginningDate] 
     * @param {string} [periodEndingDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getOffersListOffers(nameOrIsbn?: string, offererId?: number, status?: string, venueId?: number, categoryId?: string, creationMode?: string, periodBeginningDate?: string, periodEndingDate?: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getOffersListOffers(this.basePath, nameOrIsbn, offererId, status, venueId, categoryId, creationMode, periodBeginningDate, periodEndingDate, options)
    }
    /**
     * 
     * @summary Autocomplete offerers on name or SIREN.
     * @param {string} q 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getPcOfferers(q: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getPcOfferers(this.basePath, q, options)
    }
    /**
     * 
     * @summary get_reimbursements_csv <GET>
     * @param {string} [venueId] 
     * @param {string} [reimbursementPeriodBeginningDate] 
     * @param {string} [reimbursementPeriodEndingDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getReimbursementsGetReimbursementsCsv(venueId?: string, reimbursementPeriodBeginningDate?: string, reimbursementPeriodEndingDate?: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getReimbursementsGetReimbursementsCsv(this.basePath, venueId, reimbursementPeriodBeginningDate, reimbursementPeriodEndingDate, options)
    }
    /**
     * 
     * @summary get_user_offerer <GET>
     * @param {string} offererId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getUserofferersGetUserOfferer(offererId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getUserofferersGetUserOfferer(this.basePath, offererId, options)
    }
    /**
     * 
     * @summary check_activation_token_exists <GET>
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getUsersCheckActivationTokenExists(token: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getUsersCheckActivationTokenExists(this.basePath, token, options)
    }
    /**
     * 
     * @summary get_profile <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getUsersGetProfile(options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getUsersGetProfile(this.basePath, options)
    }
    /**
     * 
     * @summary validate_new_offerer <GET>
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getValidateValidateNewOfferer(token: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getValidateValidateNewOfferer(this.basePath, token, options)
    }
    /**
     * 
     * @summary validate_offerer_attachment <GET>
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getValidateValidateOffererAttachment(token: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getValidateValidateOffererAttachment(this.basePath, token, options)
    }
    /**
     * 
     * @summary fetch_venue_labels <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getVenueLabelsFetchVenueLabels(options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getVenueLabelsFetchVenueLabels(this.basePath, options)
    }
    /**
     * 
     * @summary get_venue_types <GET>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getVenueTypesGetVenueTypes(options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getVenueTypesGetVenueTypes(this.basePath, options)
    }
    /**
     * 
     * @summary list_venue_providers <GET>
     * @param {number} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getVenueprovidersListVenueProviders(venueId: number, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getVenueprovidersListVenueProviders(this.basePath, venueId, options)
    }
    /**
     * 
     * @summary get_venue <GET>
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getVenuesGetVenue(venueId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getVenuesGetVenue(this.basePath, venueId, options)
    }
    /**
     * 
     * @summary get_venue_stats <GET>
     * @param {string} humanizedVenueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getVenuesGetVenueStats(humanizedVenueId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getVenuesGetVenueStats(this.basePath, humanizedVenueId, options)
    }
    /**
     * 
     * @summary get_venues <GET>
     * @param {boolean} [validatedForUser] 
     * @param {boolean} [validated] 
     * @param {boolean} [activeOfferersOnly] 
     * @param {number} [offererId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async getVenuesGetVenues(validatedForUser?: boolean, validated?: boolean, activeOfferersOnly?: boolean, offererId?: number, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.getVenuesGetVenues(this.basePath, validatedForUser, validated, activeOfferersOnly, offererId, options)
    }
    /**
     * 
     * @summary patch_booking_by_token <PATCH>
     * @param {string} token 
     * @param {string} [email] 
     * @param {string} [offerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchBookingsPatchBookingByToken(token: string, email?: string, offerId?: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchBookingsPatchBookingByToken(this.basePath, token, email, offerId, options)
    }
    /**
     * 
     * @summary edit_business_unit <PATCH>
     * @param {number} businessUnitId 
     * @param {BusinessUnitEditionBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchFinanceEditBusinessUnit(businessUnitId: number, body?: BusinessUnitEditionBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchFinanceEditBusinessUnit(this.basePath, businessUnitId, body, options)
    }
    /**
     * 
     * @summary cancel_educational_offer_booking <PATCH>
     * @param {string} offerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchOffersCancelEducationalOfferBooking(offerId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchOffersCancelEducationalOfferBooking(this.basePath, offerId, options)
    }
    /**
     * 
     * @summary edit_educational_offer <PATCH>
     * @param {string} offerId 
     * @param {PatchEducationalOfferBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchOffersEditEducationalOffer(offerId: string, body?: PatchEducationalOfferBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchOffersEditEducationalOffer(this.basePath, offerId, body, options)
    }
    /**
     * 
     * @summary patch_all_offers_active_status <PATCH>
     * @param {PatchAllOffersActiveStatusBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchOffersPatchAllOffersActiveStatus(body?: PatchAllOffersActiveStatusBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchOffersPatchAllOffersActiveStatus(this.basePath, body, options)
    }
    /**
     * 
     * @summary patch_offer <PATCH>
     * @param {string} offerId 
     * @param {PatchOfferBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchOffersPatchOffer(offerId: string, body?: PatchOfferBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchOffersPatchOffer(this.basePath, offerId, body, options)
    }
    /**
     * 
     * @summary patch_offers_active_status <PATCH>
     * @param {PatchOfferActiveStatusBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchOffersPatchOffersActiveStatus(body?: PatchOfferActiveStatusBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchOffersPatchOffersActiveStatus(this.basePath, body, options)
    }
    /**
     * 
     * @summary edit_educational_stock <PATCH>
     * @param {string} stockId 
     * @param {EducationalStockEditionBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchStocksEditEducationalStock(stockId: string, body?: EducationalStockEditionBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchStocksEditEducationalStock(this.basePath, stockId, body, options)
    }
    /**
     * 
     * @summary edit_shadow_stock <PATCH>
     * @param {string} stockId 
     * @param {EducationalOfferShadowStockBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchStocksEditShadowStock(stockId: string, body?: EducationalOfferShadowStockBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchStocksEditShadowStock(this.basePath, stockId, body, options)
    }
    /**
     * 
     * @summary transform_shadow_stock_into_educational_stock <PATCH>
     * @param {string} stockId 
     * @param {EducationalStockCreationBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchStocksTransformShadowStockIntoEducationalStock(stockId: string, body?: EducationalStockCreationBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchStocksTransformShadowStockIntoEducationalStock(this.basePath, stockId, body, options)
    }
    /**
     * 
     * @summary patch_profile <PATCH>
     * @param {PatchProUserBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchUsersPatchProfile(body?: PatchProUserBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchUsersPatchProfile(this.basePath, body, options)
    }
    /**
     * 
     * @summary patch_user_tuto_seen <PATCH>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchUsersPatchUserTutoSeen(options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchUsersPatchUserTutoSeen(this.basePath, options)
    }
    /**
     * 
     * @summary patch_user_tuto_seen_legacy <PATCH>
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchUsersPatchUserTutoSeenLegacy(userId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchUsersPatchUserTutoSeenLegacy(this.basePath, userId, options)
    }
    /**
     * 
     * @summary validate_user <PATCH>
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchValidateValidateUser(token: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchValidateValidateUser(this.basePath, token, options)
    }
    /**
     * 
     * @summary edit_venue <PATCH>
     * @param {string} venueId 
     * @param {EditVenueBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async patchVenuesEditVenue(venueId: string, body?: EditVenueBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.patchVenuesEditVenue(this.basePath, venueId, body, options)
    }
    /**
     * 
     * @summary update_offerer_demarches_simplifiees_application <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postBankInformationsUpdateOffererDemarchesSimplifieesApplication(options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postBankInformationsUpdateOffererDemarchesSimplifieesApplication(this.basePath, options)
    }
    /**
     * 
     * @summary update_venue_demarches_simplifiees_application <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postBankInformationsUpdateVenueDemarchesSimplifieesApplication(options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postBankInformationsUpdateVenueDemarchesSimplifieesApplication(this.basePath, options)
    }
    /**
     * 
     * @summary handle_task <POST>
     * @param {UpdateBatchAttributesRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postCloudTasksHandleTask(body?: UpdateBatchAttributesRequest, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postCloudTasksHandleTask(this.basePath, body, options)
    }
    /**
     * 
     * @summary handle_task <POST>
     * @param {DeleteBatchUserAttributesRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postCloudTasksHandleTask_1(body?: DeleteBatchUserAttributesRequest, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postCloudTasksHandleTask_1(this.basePath, body, options)
    }
    /**
     * 
     * @summary handle_task <POST>
     * @param {UpdateBatchAttributesRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postCloudTasksHandleTask_2(body?: UpdateBatchAttributesRequest, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postCloudTasksHandleTask_2(this.basePath, body, options)
    }
    /**
     * 
     * @summary handle_task <POST>
     * @param {TransactionalNotificationData} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postCloudTasksHandleTask_3(body?: TransactionalNotificationData, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postCloudTasksHandleTask_3(this.basePath, body, options)
    }
    /**
     * 
     * @summary handle_task <POST>
     * @param {SendTransactionalEmailRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postCloudTasksHandleTask_4(body?: SendTransactionalEmailRequest, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postCloudTasksHandleTask_4(this.basePath, body, options)
    }
    /**
     * 
     * @summary handle_task <POST>
     * @param {SendTransactionalEmailRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postCloudTasksHandleTask_5(body?: SendTransactionalEmailRequest, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postCloudTasksHandleTask_5(this.basePath, body, options)
    }
    /**
     * 
     * @summary handle_task <POST>
     * @param {UpdateSendinblueContactRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postCloudTasksHandleTask_6(body?: UpdateSendinblueContactRequest, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postCloudTasksHandleTask_6(this.basePath, body, options)
    }
    /**
     * 
     * @summary handle_task <POST>
     * @param {UpdateProAttributesRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postCloudTasksHandleTask_7(body?: UpdateProAttributesRequest, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postCloudTasksHandleTask_7(this.basePath, body, options)
    }
    /**
     * 
     * @summary create_offerer <POST>
     * @param {CreateOffererQueryModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postOfferersCreateOfferer(body?: CreateOffererQueryModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postOfferersCreateOfferer(this.basePath, body, options)
    }
    /**
     * 
     * @summary generate_api_key_route <POST>
     * @param {string} offererId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postOfferersGenerateApiKeyRoute(offererId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postOfferersGenerateApiKeyRoute(this.basePath, offererId, options)
    }
    /**
     * 
     * @summary create_educational_offer <POST>
     * @param {PostEducationalOfferBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postOffersCreateEducationalOffer(body?: PostEducationalOfferBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postOffersCreateEducationalOffer(this.basePath, body, options)
    }
    /**
     * 
     * @summary create_shadow_stock_for_educational_showcase_offer <POST>
     * @param {string} offerId 
     * @param {EducationalOfferShadowStockBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postOffersCreateShadowStockForEducationalShowcaseOffer(offerId: string, body?: EducationalOfferShadowStockBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postOffersCreateShadowStockForEducationalShowcaseOffer(this.basePath, offerId, body, options)
    }
    /**
     * 
     * @summary create_thumbnail <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postOffersCreateThumbnail(options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postOffersCreateThumbnail(this.basePath, options)
    }
    /**
     * 
     * @summary post_offer <POST>
     * @param {PostOfferBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postOffersPostOffer(body?: PostOfferBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postOffersPostOffer(this.basePath, body, options)
    }
    /**
     * 
     * @summary create_educational_stock <POST>
     * @param {EducationalStockCreationBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postStocksCreateEducationalStock(body?: EducationalStockCreationBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postStocksCreateEducationalStock(this.basePath, body, options)
    }
    /**
     * 
     * @summary upsert_stocks <POST>
     * @param {StocksUpsertBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postStocksUpsertStocks(body?: StocksUpsertBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postStocksUpsertStocks(this.basePath, body, options)
    }
    /**
     * 
     * @summary post_change_password <POST>
     * @param {ChangePasswordBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postUsersPostChangePassword(body?: ChangePasswordBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postUsersPostChangePassword(this.basePath, body, options)
    }
    /**
     * 
     * @summary post_for_password_token <POST>
     * @param {ResetPasswordBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postUsersPostForPasswordToken(body?: ResetPasswordBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postUsersPostForPasswordToken(this.basePath, body, options)
    }
    /**
     * 
     * @summary post_new_password <POST>
     * @param {NewPasswordBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postUsersPostNewPassword(body?: NewPasswordBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postUsersPostNewPassword(this.basePath, body, options)
    }
    /**
     * 
     * @summary signin <POST>
     * @param {LoginUserBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postUsersSignin(body?: LoginUserBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postUsersSignin(this.basePath, body, options)
    }
    /**
     * 
     * @summary signup_pro <POST>
     * @param {ProUserCreationBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postUsersSignupPro(body?: ProUserCreationBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postUsersSignupPro(this.basePath, body, options)
    }
    /**
     * 
     * @summary create_venue_provider <POST>
     * @param {PostVenueProviderBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postVenueprovidersCreateVenueProvider(body?: PostVenueProviderBody, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postVenueprovidersCreateVenueProvider(this.basePath, body, options)
    }
    /**
     * 
     * @summary post_create_venue <POST>
     * @param {PostVenueBodyModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postVenuesPostCreateVenue(body?: PostVenueBodyModel, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postVenuesPostCreateVenue(this.basePath, body, options)
    }
    /**
     * 
     * @summary upsert_venue_banner <POST>
     * @param {string} venueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postVenuesUpsertVenueBanner(venueId: string, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postVenuesUpsertVenueBanner(this.basePath, venueId, options)
    }
    /**
     * 
     * @summary dms_webhook_update_application_status <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postWebhooksDmsWebhookUpdateApplicationStatus(options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postWebhooksDmsWebhookUpdateApplicationStatus(this.basePath, options)
    }
    /**
     * 
     * @summary ubble_webhook_update_application_status <POST>
     * @param {string} ubbleSignature 
     * @param {WebhookRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postWebhooksUbbleWebhookUpdateApplicationStatus(ubbleSignature: string, body?: WebhookRequest, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postWebhooksUbbleWebhookUpdateApplicationStatus(this.basePath, ubbleSignature, body, options)
    }
    /**
     * 
     * @summary unsubscribe_user <POST>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async postWebhooksUnsubscribeUser(options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.postWebhooksUnsubscribeUser(this.basePath, options)
    }
    /**
     * 
     * @summary update_venue_provider <PUT>
     * @param {PostVenueProviderBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public async putVenueprovidersUpdateVenueProvider(body?: PostVenueProviderBody, options?: any) {
        const functionalApi = DefaultApiFp(this, this.configuration)
        return functionalApi.putVenueprovidersUpdateVenueProvider(this.basePath, body, options)
    }
}
